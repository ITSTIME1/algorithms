# 문제분석


# 개미가 일렬로 이동할때
# 가자 ㅇ앞의 개미를 제외한 나머지 개미는 앞의 개미가 한마리씩 있다
# 만약 두개미그룹이 좁은 길에서 만났을대 어떻게 이동을하냐

# 한 개미가 다른 개미를 뛰어넘는다 그럼 뛰어넘는 개미를 제외한 뛰어넘기를 받는 개미는
# 전진한다


# 하지만 개미가 모두 점프하는건아니고 자신의 앞에 반대방향에서 오는 개미가
# 있는 경우에만 점프를 하게 된다
# 첫 번째 그룹이 ABC 로 움직이고 두번째 그룹의 개미가 dEF 순으로 움직인다고 했을때


# 음 그니까 첫 번째 그룹이 ABC 순으로 움직인다고 했고
# 두번재 그룹이 DEF 순으로 움직인다면
# 대치 되었을때
# CBA DEF 순으로 대치가 되어 있을거니까
# 먼저 알아야하는건 자신의 앞에 반대 방향으로 이동하는 개미가 있냐 없냐이다
# A입장에선 D가 있다 그렇기 때문에
# 옮기게 되면CBD AEF 이렇게 된다 1초가 지났을때의 모습이고
# D가 점프를하게된다면 A는 그냥 직진하는 것 처럼 보인다

# CBD가 오게 되었다면 이제 자신의 앞에 반대방향으로 이동하는 개미가 있냐 없냐를 판단한다
# C입장에선 자신의 앞에 B가 있기 때문에 반대방향이 아닌 같은 방향으로 이동하는 개미기 때문에 C앞에는 없다
# 하지만 B 입장에선 D가 반대방향으로 이동하고 있기 때문에 D가 있고 D입장에선 반대방향으로 이동하는 B 가있기에
# D, B가 반대방향으로 이동하는ㄱ ㅐ미들이다
# 그리고 AEF 에서 A 앞에 E가 반대방향으로 이동하기 때문에 A가 이동할 수 있으며
# 위에서도 DB가 서로 이동할 수 있다
# 그렇기에 D, B, A 가 되고 E또한 A가 반대방향으로 이동하는 개미기 때문에
# DBAE 가 반대방향으로 이동하는 개미들이 된다
# C와 마찬가지로 F 같은 경우 자신의 앞에 E가 있지만 E는 같은방향으로 이동하는 개미기 때문에
# F앞엔 반대방향의 개미가 없다 이렇게 2초가 지났고
# 만약 3초라면
# CDB EAF = 2초상태
# 똑같은 개념으로 3초가 지난다면
# DCE BFA 상태가 된다
# 만약 4초가 된다면
# DEC FBA 가 되고
# 만약 5초가 된다면
# DEF CBA 가 된다
# 원상 복귀가 된다


# 일단 그러면 그룹끼리 반대방향인지 반대방향이 아닌지 알아야 하고
# 반대방향의 개미가 있을때
# 인덱스 교환해주면
# 처음부터 리스트를 순회하면서
# 자기 앞에 반대방향으 ㅣ개미가 있다면
# 자기랑 인덱스 교환
# 그렇게 한다면 마지막까지 잘 돌아가는데
# T 초 동안 반복시켜 준다면 가능할거 같네

# 근데 서로 다른 개미라는걸 어떻게 알지
# 아
# 리스트에 포함되어 있는지 안되어 있는지를 보면 되겠다
# 그룹 리스트가 아닌 개미가 온다면 반대편 그룹에서 온 개미들이기 떄문에
# 이렇게 판단하면ㄷ ㅚ겠따
# 해서 T
# 첫번째 그룹은 왼쪽에서 오른쪽 두번째는 첫번째으 ㅣ반ㄷ 
# ㅇㅋㅇㅋ 


n1, n2 = map(int, input().split())
arr1, arr2 = list(input()), list(input())
t = int(input())

# 첫번째 그룹은 반대로 이동하기 때문에 sort
arr1.sort(reverse=True)

# 그렇구만 뭔가 
s = arr1+arr2

for _ in range(t):
	for i in range(len(s)-1):
		if s[i] in arr1 and s[i+1] not in arr1:
			s[i], s[i+1] = s[i+1], s[i]
			if s[i+1] == arr1[-1]:
				break
print("".join(s))