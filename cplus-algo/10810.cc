#include <iostream>
using namespace std;

int main() {	

	int n, m;
	cin >> n >> m;

	// 배열을 선언
	// 배열을 선언할때는 반드시 상수의 배열크기가 지정되어 있어야함
	// 배열의 선언과 동시에 초기화가 가능하고
	// 선언만도 가능함.
	// 또한 크기를 선언하지 않았지만 배열의 요소들만으로도 크기를 정할 수 있음
	// 즉 만약 int arr[] = {1,2,3,4}; 이런 식으로 되어 있다면
	// arr의 배열의크기는 1,2,3,4 배열의 요소의 크기로 지정 된다는 말임
	// 따라서 배열에 요소가 존재한다면 존재하는 배열들의 개수가 곧 배열의 크기가 됨.


	// 또한 배열크기를 명시적으로 지정해주고 배열의 요소들을 일부 정의하지 않게 되면
	// 나머지는 0으로 초기화됨 아래와 같이.
	// 따라서 하나만 정의해주고 나머지는 초기화가 안된 것으로 볼 수 있음. 그렇다면 초기화 되지 않은 부분에 대해서는 0으로 초기화가 됨
	int arr[101] = {0};

	// 그렇게 m만큼 돌리기 때문에 이렇게 받고
	for (int i = 0; i < m; i++) {
		// 범위와 공을 받아준다음에
		int start, end, ball;
		cin >> start >> end >> ball;
		// 101개의 메모리를 확보해둔것이고
		// 각각의 index에는 포인터주소를 가지고 있으니
		// 해당 index의 주소는 고유하자나 그 값이 저장되어 있는 주소니까
		// 따라서 그 주소에 저장되어 있는 값이 ball인거고
		// 그럼 그 값에 ball이 이미 있다면 ball을 갈아 끼우는 작업을 해주어야 하기 때문에
		// 갈아 끼운다는 것이 뽑는다는 의미로 해석해보면 pop을 생각할 수 있으나
		// 어짜피 공의 번호를 변경하는 일이기 때문에 
		// 메모리주소는 그대로이면서
		// 즉 바구니의 위치는 그대로이면서 
		// 그 바구니에 들어갈 공의 번호만 바꾸면 되는거지
		// 따라서 메모리 주소를 바꾸는게 아니기 때문에
		// ball의 값만 바꾸면 되는거지
		// 그렇게 되면 있던 공을 빼고 새로운 공을 집어 넣는 작업도
		// 공의 값만 바꾸어 주면 되기 때문에 새롭게 초기화를 해주게 되면
		// 공을 바꾸게 되는거지.

		for (int j = start; j  <= end; j++) {
			arr[j] = ball;
		}
	}


	for (int i = 1; i < n+1; i++) {
		cout << arr[i] << " ";
	}
	return 0;
}