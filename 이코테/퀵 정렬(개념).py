array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


# 퀵정렬

def quick_start(array, start, end):
	# start 값이 0 인데 end 값은 배열의 가장 끝 값인데
	# 만약 배열의 끝값과 시작 값이 같다는건 [0] 이런 리스트안에 요소가 하나 밖에 없다는 뜻이다 그렇기 떄문에
	# 이런 경우는 재귀의 deapth 를 넘어가기 때문에 return 종료 해주어야 한다.

	if start >= end:
		return

	# pivot = 기준 숫자
	pivot = start
	# left = 기준 값을 제외한 다음 인덱스 부터
	left = start+1
	# 끝 값은 end 즉 len(array) - 1 인덱스
	right = end

	# 1 부터 배열 전체를 훑어보고 right 가 len(array) - 1 의 인덱스 이기 때문에
	# 이 때 까지 쭉 반복한다.

	while left <= right:
		# 왼쪽부터 시작하는 반복은
		# pivot 보다 큰 숫자를 찾고
		# 오른쪽 즉 배열의 끝 부터 시작하는 반복문은111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
		# pivot 보다 작은 숫자를 찾아서
		# 겹치지 않는다면
		# 왼쪽 숫자와 오른쪽 숫자를 바꿔주고
		# 만약 숫자가 엇갈리는 상황이 온다면
		# 작은 숫자 right 쪽에서 잡은 숫자를 
		# pivot 과 바꿔주면
		# 자연스럽게 가운데에 오는 숫자는 배열의 중간숫자로 맞춰주기ㅗ
		# 이렇게 다 찾은 값이 있다면
		# 바꾼 숫자들을 이제 왼쪽과 오른쪽을 따로 정렬을 같은 방법대로 시작하면
		# 정렬이 가능하다.
		# left 는 요소기 때문에 배열에서 반복을 해야 되기 때문에 계속 elft 값은 증가하게 되고 
		# 요소 중 pivot 값 보다 큰 값을 찾으면 되기 때문에#
		# array[left]값이  pivot 보다 값이 크다면 다음 while 문으로 넘어간다 다음 while 문이란 right while 문을 의미한다.
		# 요소를 하나씩 살펴보면서 left 값이 pivoty 보다 작거나 같으면 left 원소를 하나 씩 늘려준다 이유는 다음 요소를 검사 해야 하기 때문이다.	
		while left <= end and array[left] <= array[pivot]:
			left += 1

			# right > start 의미는 right 는 맨 뒤의 인덱스 부터 차례대로 하나씩 right - 1 하면서 줄여갈건데
			# pivot 기준값으 index[0] 값으로 정해져 있기 때문에 pivot + 1 한 값까지 검사를 진행한다.
			# 만약 right 값이 start 시작 값보다 작게 된다면 while 문을 벗어난다
			# 오른ㅉ고에서는 array[right] 값이 pivoty 보다 작은 값을 찾아야 하기 때문에
			# pivot 보다 작은 값을 발견한다면
			# 이번엔 거꾸로 검사하는 것이기 때문에 right를 하나씩 줄여준다.
		while right > start and array[right] >= array[pivot]:
			right -= 1

		# 이렇게 검사를 끝냈으면
		# 엇갈린 값이랑 엇갈리지 않은 값을 확인해야 한다
		# 엇갈리는 이유는 left 또한 시작부터 end 까지 반복하게 되고
		# right 또한 right > start 보다 클 때까지만 반복 하기 때문에 
		# 서로 반복을 하다보면 한 지점에서 엇갈리는 지점이 나오게 된다
		# 그렇기 때문에 엇갈리지 않았다면 서로의 위치를 바꿔주고
		# 만약 엇갈렸다면 right 족에서 선택한 작은 값을 pivot 값과 바꿔준다.
		if left > right:
			array[right], array[pivot] = array[pivot], array[right]
		else:
			array[left], array[right] = array[right], array[left]
	# 이렇게 분할이 완료되면
	# 왼쪽과 오른쪽에는 pivot 기준 값보다 왼쪽은 작은 값이
	# pivot 기준으로 오른쪽에는 pivot 값보다 큰 값만 위치하게 되며
	# 이제 서로의 정렬만 하면 된다.

	# 왼쪽 = [1, 4, 2, 0 , 3, [5], 6, 9, 7, 8] = right - 1 = 4
	# 오른쪽 = []
	print(array)
	quick_start(array, start, right - 1)
	quick_start(array, right+1, end)

quick_start(array, 0, len(array) - 1)
print(array)