
// 과거에 상수를 선언할때 final 키워드를 사용함.
// final 제어자를 할당해줌으로써, 한번 설정된 값은 변경하지 않도록 해준다.
// 동시에 static을 사용해서, 메모리에 반복적으로 값이 올라가지 않고, 한 번만 메모리에 올려두어,
// 필요할 때 메모리에서 꺼내 쓰는 방식을 사용할 수 있다.
// 이런식으로 하게 되면 private와 같이 접근 제어자가 할당 되어 있기 때문에
// 일관성이 없다. 
// 상수에 대한 내용은 변하지 않는 값이기 때문에, 해당 값을 가지고 와서 계산에 필요한 부분에 할당하길 원한다.
// 하지만 클래스 내에 정의한 상수변수 같은 경우는, 클래스 내에서의 접근은 용이할지 몰라도
// OOP의 특징으로, 클래스 내부에 직접 접근을 할 수 없게 되는 패러다임에 영향을 주게 된다.
// 그렇다는 것은 곧, 상수에 대한 접근에 제한이 생기게 되고, 필요한 상수값이 클래스 여기저기에 분포하고 있다면
// 관리하기 어려울 뿐더러, 정작 정말 필요한 상황에서의 상수를 사용하지 못할 수 있다.
// 그러므로, 상수를 해당 방식으로 관리하게 되는 것은, 클래스 내부에서는 용이하나
// 전역적으로 다뤄지는 상수에 대해서는 접근의 문제가 존재한다고 볼 수 있다.

public class EnumerationTest {
	private final static MONDAY = 1;
	private final static TUESDAY = 2;
}

// 다른 방법으로 상수를 선언하는 것에는 인터페이스를 이용하는 방법이 존재한다.
// interface에는 추상 메서드만 선언할 수 있는게 아닌, 상수 변수도 선언이 가능하다.

// interface에서는 public static final 키워드를 생략할 수 있기 때문에
// 가독성이 좋아진다는 것은 장점이다.
// 하지만 인터페이스로 선언시에 문제가 발생한다.
// 원론적인 문제로 접근해야 한다.
// 먼저, 상수라고 하는 것은, 변하지 않는 숫자 값을 의미한다.
// 따라서 하나의 숫자로 이루어진 것을 의미한다.
// 그렇다면, 개발자의 의도와 다른 상수값의 비교연산을 통해, 발생된 문제는 어떻게 잡아낼 수 있을까

// 즉, 잘못된 상수가 할당되어 비교가 되고 있음에도 불구하고, 컴파일 에러 없이 실행된다.
// 개발자의 실수이긴 하나, 상수값으로 인해 전체 프로그램에 영향을 준다면, 그리 가벼운 문제는 아니다.
// 즉 interface로 상수를 선언하는 것 또한, 상수라는 원론적인 개념에서의 문제가 발생되게 되고, 이 문제를 개발자가 개발 중 발생시키게 되면
// 결국 프로그램의 유지보수 측면에도 필히 영향이 갈 것으로 예상된다.


interface DAY {
	int MONDAY = 1;
	int TUESDAY = 2;
	int THURSDAY = 3;

}


// 혹은 자체 클래스 상수를 만든다.
// 자체 클래스 상수라고 하는것은, 아래와 같이
// 클래스 내부에서, 자신의 클래스의 인스턴스를 생성한뒤 객체로 취급하자는 것이다.
// interface에서 사용하고 있던 상수에 대한 원론적인 문제는 사라졌기 때문에
// 비교연산에서의 값에 대한 변경여부를 걱정할 필요가 사라진다.
// 하지만 이 역시 가독성이 좋지 않게 되고, 상수에 대한 메모리 비용이 커지게 된다는 단점이 있다.
// 또한 switch문 같은 경우에는, 사용할 수 있는 타입에 제한이 있기 때문에, 자체클래스인스턴스를 사용하게 되면
// 스위치문과 같은 곳에는 사용하지 못한다는 단점이 존재한다.
class Month {
	public final static Month JANUARY = new Month();
}





// 위와 같은 문제를 통해서, 자바에서는 상수만을 따로 다루는 enum 타입 클래스를 배포하게 되었다.
// enum은 자바에서 독립된 특수환 클래스로 구분한다.
// 클래스는 객체화가 가능하고, 객체이기 때문에, 힙 메모리에 저장되며
// 각 enum 상수들은, 별개의 메모리 주소값을 가짐으로써,완벽히 독립된 상수를 구성할 수 있는것이다.

// 이런식으로 enum을 맵핑할 수 있음.
// 즉 MONDAY라는 enum상수에 접근하게 되면, 
// 열거형에 나열된 값들 하나하나가, 상수객체로 취급되므로
// 힙에다가 저장이됨.
// 그러므로 
// 열거형이의 생성자를 통해서
// 각 열거형 객체에다가 값을 넣어주낟.
// 예를들어
enum Week {
	MONDAY("월요일"),
	THUESDAY,
	WEDNESDAY,
	THURSDAY,

	private String season;
	// 싱글톤 패턴 적용.
	private Week(String season) {
		this.season = season;
	}

	public String getSeason(){
		return this.season;
	}
}

Week w = Weeㅏ.MONDAY;
String season = w.getSeason();

// 위와 같은 enum 클래스가 존재할때

// 각 열거형들은 모두 힙 메모리에 저장이 되기 때문에
// 열거형 인스턴스가 생성되게 되면
// Week m = Week.MONDAY;
// 맵핑되어 있는 문자열이 String season 파라미터로 받게 되고
// 그로 인해 문자열을 저장할 수 있게 한다.

// 즉 원하는 열거형 객체를 인스턴스화 시킨다면, 열거형에 지정되어 있는 문자열이
// 생성자를 통해서, this.season 변수에 할당이 되고, 그로 인해 getter 메소드를 이용해서, 문자열을 가지고 올 수 있는 것이다.

// enum도 일종의 타입이기 때문에
// 변수로 만들어서 사용이 가능하다.


// 또한 enum은 기본 타입이 아닌, reference 타입이다.
// 그렇기 때문에, 힙 영역에 저장 된다.
// 참조 타입이기 때문에, 널도 저장이 가능하다.
// 또 주소를 비교하는 연산에서 힙 메모리에 있는 열거형 객체에 똑같이 바라보고 있게 되니
// 결국 true라는 값이 나오게 되낟.
// 왜냐하면 스택영역에 있는 변수들이 아래에서 testEnum과 같이
// 이러한 변수들이 힙 영역에 있는 데이터의 주소값이 같기 때문이다.
// 즉 힙영역에 저장된 같은 주소를 가리키게 되면, 주소 비교 연산에서도 true가 반환된다는 것이다.
Week testEnum = Week.MONDAY;


// 사실상 enum은 아래와 같이 타입 세이프한 패턴으로 작성도리 수 있다.
final class Season {
	public static final Season SPRING = new Season("SPRING");
	// 즉 열거타입을 자기자신 객체로 만들어준다.
	private String season;

	// 인스턴스를 만들때 생성자를 거치게 되는데, 생성자의 접근 지정자가 private라는 것은
	// 외부에서 해당 클래스의 인스턴스를 자유롭게 생성하지 못한다는 것이다.
	// 따라서 season내부에서는 private에 접근이 가능하므로
	//  static하게 메모리에 인스턴스를 딱 한번 올려두게 되고

	// 외부에서는 상수의 대한 값의 변경을 제한하기 위해서, 생성자를 private로 지정하여 접근이 불가능하게 만들어줌으로써
	// 메모리 영역에 있는 열거형객체는 딱 한개만 존재하게된다.

	private Season(String season) {
		this.season = season;
	}
}

// enum은 런타임이 아닌 컴파일타임에 모든 값을 알고 있어야 하는 규칙이 존재함.
// 컴파일 타임에 모든 값을 알고 있기 때문에, 런타임 시에 동적으로 값이 변하게 하지 않는다.
// 즉 이러한 동적으로 할당되는 것은 금지하는 것이 규칙이다.



@Override
public String getInstance() {
	return this.season;
}






