

// 싱글톤 패턴은
// 똑같은 인스턴스를 새로 만들지 않고, 기존의 인스턴스를 가져와서 활용하는 기법을 말한다.
// 디자인 패턴 중에 하나이며, 이러한 싱글톤 패턴은 적용하고자 하는 객체가 비교적 큰 메모리를 차지하게 되는 경우
// 적용이 적합하다.

// 메모리를 많이 차지한다는 것은, 객체 자체가 크다는 것을 의미하며, 객체 내부에 포함되어 있는 멤버들이
// 무거운 작업을 한다는 것을 의미한다.
// 그러므로, 이러한 객체가 하나가 아닌 여러개가 생성된다면, 이 객체가 차지하는 메모리의 크기도 커지게 될 뿐더러
// 메모리의 낭비로 이루어진다.



// 예를 들어서, 데이터베이스 연결 모듈을 예로 들어볼 수 있는데
// 데이터베이스에 접속하는 작업은 그 자체로 무거운 작업에 속하며, 또한 한번만 객체를 생성하고 돌려쓰면 되는 경우가 존재한다.
// 즉 다시 말해, 여러번 생성할 필요가 없다는 것을 의미한다.
// 그러므로 이러한 상황에서 싱글톤 패턴을 적용할 수 있음을 알 수 있다.


// 결국 싱글톤 패턴이 적용하는 대상은, 그 대상이 프로그램 내에서 유일해도 되고 리소스 낭비가 되지 않을 수 있으면
// 싱글톤 패턴을 적용할 수 있다.

// 그럼 싱글톤 패턴을 구현하는 방법에 대해서 살펴보자.

// 싱글톤 패턴의 주요 목적은, 외부에서 new를 통해 여러 개의 생성자를, 생성하는 것을 방지하는데 있다.
// 그러므로, 생성자접근을 할 수 없도록, 생성자에 private 접근 제어자를 할당해준다.

// 그러면, 내부에서는 생성자에 접근이 가능하지만, 외부에서는 생성자에 접근이 불가능하기 때문에
// 생성자의 무차별 생성을 막아주게 된다.

// 그래서 미리 해당 객체를 생성해놓고, 그 객체의 인스턴스를 가지고 오는 방법으로
// 사용될 수 있다.


// Eager Initialization
public class EagerSingleTone {

	private static final singleTone INSTANCE = new SingleTone();
	// 생성자의 접근제어자를 private로 만들어서, 외부에서 무분별한 new 키워드를 통해
	// 생성자가 생성되는 것을 방지한다.
	private singleTone(){}

	// getInstance() 메소드를 사용해서, 미리 메모리에 생성해 두었던, 싱글톤이 적용된 객체를
	// 반환한다.
	// 이렇게 하면, 필요할 때마다, 이미 메모리에 올라가져 있는 싱글톤 객체를 돌려가면서 사용하는 것이기 때문에
	// 메모리에 똑같은 객체를 생성하지 않더라도 이런식으로 전역적으로 공통된 객체를 사용할 수 있게 해준다.
	public static singleTone getInstance() {
		return INSTANCE;
	}

}


// 하지만 위 코드의 경우, 예외 처리를 할 수가 없다는 단점이 존재한다.
// 예외 처리를 할수 없다는 것은, 메모리에 올라가게 끔 미리 초기화를 진행했지만
// 메모리에 정상적으로 올라가져 있는지, 혹은 그 외 Exception이 발생한 경우는 없었는지
// 파악하기가 힘들다. 그렇기 때문에 이러한 점에서 예외처리를 보다 정확히 해주기 위해서
// static block initialization을 사용할 수 있다.


// 스태틱 블럭은 초기화 기법은, 인스턴스 생성에서 try-catch구문을 통해
// 인스턴스 생성에, 어떠한 오류가 발생될 경우, try-catch내부에서 잡아주기 때문에
// 인스턴스 생성에 예외를 처리할 수 있게 되어 Eager Initialization 에서의 단점을 보안해주는 기법이 된다.

public class StaticBlockSingleTone{
	// 이때 Eager Initialization과 차이점은, final키워드를 붙이지 않았다는 것이다.
	// final 키워드를 붙이게 되면, 상수의 특징과 함께, 선언과 동시에 초기화가 이루어져야 하지만
	// static 블럭에서 초기화를 해야되기 때문에, 인스턴스 변수만 메모리에 올린 상태로
	// static 블럭에서 초기화를 진행할 수 있도록 구현해준다.
	private static SingleTone INSTANCE;

	// 생성자는 마찬가지로 접근 지정자가 private하게끔 만들어준다.
	private SingleTone() {}


	// static 블럭을 이용해 예외 처리를 진행할건데
	static {
		try {
			// 여기에서 인스턴스를 할당해준다.
			// static 블럭은 클래스가 로딩되고, 클래스 변수가 준비된 후
			// 자동으로 실행되는 블럭을 의미한다.
			INSTANCE = new SingleTone();
		} catch(Exception e) {
			// log.();
		}
	}

	public static SingleTone getInstance() {
		return INSTANCE;
	}
}



// lazy initialization
// lazy : 게으른 이라는 뜻을 가지고 있다.
// 즉 클래스 입장에서 게으르게 초기화가 진행 된다는 것을 의미한다.
// 클래스 입장에서 게으르게 초기화가 된다는 것은, 늦게 초기화가 진행된다고 이해해볼 수 있다.
// 그렇다면, 게으르게 초기화 되는 것은 무엇이고, 어떤 이점이 있을까


// 우선 기존의 static 이나, eager 기법같은 경우에는 두 가지 공통점이 있으며, 차이점이 존재한다.

// 먼저 공통점으로는 static화 하기 때문에, 메모리에 미리 객체를 생성한다는 것이다.
// 차이점으로는, 초기화의 방식이 다르다. eager는 필드레벨에서, 생성자에 접근해 인스턴스를 생성하는 것이고
// static block은 말 그대로 스태틱 블럭을 사용해서 클래스가 로딩이 되고, 클래스 변수가 준비된 다음 자동으로 실행되게 지정하여
// 인스턴스를 생성하는 방식이다.

// 결국, 두 싱글톤 기법 모두 메모리에 객체를 바로 적제 한다는 것은 동일하다.
// 따라서, 두 싱글톤 기법 모두 메모리를 미리 차지하고 있다는 것을 의미할 수 있다.

// 앞서 언급했듯, 객체의 크기가 비교적 큰 것에 싱글톤 기법을 적용한다.
// 그래서 똑같은 객체가 반복적으로 사용되지 않도록 한다. 그러므로 메모리를 아낄 수 있는 전략이지만

// 객체 하나가 굉장히 많은 메모리를 차지하게 된다면, 그 하나의 객체 자체도, 메모리에 계속 올려두는 것이 비교적 단점으로 적용될 경우
// 인스턴스 생성 시점을 늦출 수 있다.

class LazySingleTone{
	private static SingleTone INSTANCE;

	private LazySingleTone () {}

	public static LazySingleTone getInstance() {
		// getInstance를 호출하는 시점은, 해당 객체가 필요로 되어지는 시점을 의미한다.
		// 그러면, 이 LazySingleTone이 한번도 생성된 적이 없다면 INSTANCE 변수만 메모리에 적제되어 있고
		// 실제 객체는 적제되어 있지 않을 것이다.
		// 그러므로, 이러한 점을 이용해서 객체의 호출시점에 INSTANCE의 NULL값 여부를 확인한다.
		// INSTANCE의 널값 여부를 확인한다는 것은 곧 객체가 생성된 적이 있는지 없는지 검사하는 것이다.
		// 만약, INSTANCE가 생성된 적이 없다면, 해당 객체가 처음으로 생성이 될 필요가 존재하는 것이기 때문에
		// INSTANCE를 생성한 뒤, 반환한다.
		// 만약, INSTANCE가 이미 생성된 적이 있어 NULL이 아니라면, 해당 객체가 처음으로 생성될 필요성이 존재하지 않는다.
		// 그러므로, 이미 한번 생성 되었던 객체를 반환한다.
		return INSTANCE == NULL ? new LazySingleTone() : INSTANCE;
	}
}


// 결국, LazyInitialization의 특징으로는, 객체의 필요시점에서 메모리를 적제한다는 것이다.
// 이렇게 초기화를 진행하게 되면, 메모리에 미리 객체를 적제하고 있지 않기 때문에 해당 인스턴스가 필요하지 않은 시점에
// 메모리의 낭비를 줄일 수 있다.

// 하지만 쓰레드 세이프 하지 않는 단점이 존재한다.

// 먼저 쓰레드 세이프 하지 않다는 것을 이해할 필요가 있다.
// 쓰레드 세이프 하지 않는 것은, Thread가 작업단위라고 생각하고

// 두개의 A, B쓰레드가 존재한다고 가정하자.
// 이때, A가 우선적으로 코드를 실행하게 되면, 코드를 위에서 아래로 읽어나간다.

// 그러면 A가 getInstance()코드에 진입하게 되고, 인스턴스의 널값 여부를 확인한다.
// 이때, 쓰레드 B도 null값을 확인한다고 하자. 삼항 연산자로 되어 있다면 INSTANCE == NULL임을 확인하는 부분이다.
// 이 부분을 B도 확인한다는 것이다. 전제는 A가 아직 인스턴스를 생성하지 않았다는 것을 전제로한다.
// 만약 위 전제가 존재하지 않는다면, 이미 인스턴스가 쓰레드 A에 의해서 생성이 되었고, 생성되고 난 이후에는
// 인스턴스가 NULL이 아니기 때문에, 기존 인스턴스를 반환한다. 결국 인스턴스를 B는 생성하지 못한다.

// 그러므로 위 전제하에 생각을 해보면, A가 인스턴스를 아직 생성하지 않았기 때문에
// B또한 == 비교 연산자를 통해 해당 값이 true가 될 수 있는 것이고,
// 그렇게 되면 A, B둘다 인스턴스를 생성하게 된 것이므로, 결국 인스턴스 한개만 생성하고자 했던 싱글톤 객체의 목적에 맞지 않게 된다.
// 따라서 이러한 문제점을 쓰레드 세이프하지 않다는 것이다.


// 자바는 멀티 쓰레드 환경을 지원하기 때문에, 여러 쓰레드들이 작업을 수행하면서
// 동시에 읽고, 쓰는 작업을 진행하게 된다. 그런 과정속에서 위와 같은 상황은 충분히 일어날 가능성이 존재하며
// 그로인해, 목적에 맞지 않는 코드를 작성하게 된다.
// 위 LazyInitialization 때문에, 안그래도 덩치가 큰 객체를 하나만 생성하기로 했지만
// 해당 싱글톤 객체 메모리의 두배를 잡아 먹어야 하기 때문에, 메모리의 손실과 싱글톤 객체목적에 둘다 만족하지 못하게 된다.


// 그럼 이러한 동시성 문제를 해결하기 위한 싱글톤 패턴은 뭐가 있을까
// ThreadSafe한 초기화방법으로, 동시성 문제를 해결하기 위해 synchronized 키워드를 통해
// 쓰레드가 동기화 작업을 수행할 수 있도록 한다.

// 즉 여러 쓰레드들이 해당 메소드에 접근하게 될 때, 쓰레드 별로 하나하나씩 접근이 가능하도록 만들어준다.
// 이렇게 하게 되면, 동시에 읽고 쓰는 작업에서 문제가 되지 않게 된다. ( 단 하나의 쓰레드만 그 시점에 적용되기 때문에 )

// 하지만 synchrozied키워드를 호출하게 된다는 것은, 여러 메소드들이 해당 메소드를 호출하게 되는 것인데
// 동기화 처리 작업에 해당 메서드를 많이 호출하게 되면서 overhead가 발생하게 된다.
// 오버헤드라고 하는것은, 작업을 처리하기 위한 시간 * 메모리가 사용되는 것을 의미한다.

// 따라서 성능 하락이 예상될 수 있다.
// 즉 Race condition이 발생되지 않도록 조절한다는 것이다. 즉 하나의쓰레드가 작업을 하게 될때
// 그 thread의 작업이 끝나기 전까지 다른 쓰레드에서 접근하지 못하도록, 잠금하는 것을 의미한다.

// Lazy Initialization 같은 경우 이러한 멀티 쓰레드 타입세이프하지 않았기 때문에
// 동시에 작성하게 되는 문제가 생기게 되었는데, synchronized 키워드를 붙이게 되면 getInstance에 접근할때
// 하나의 단일 쓰레드의 작업이 끝나기 전까지, 다른 쓰레드에서 작업을 할 수 없도록 하므로, 객체가 두 개 생성될 여지가 존재하지 않는다.


class ThreadSafeInitialization() {
	private static ThreadSafeInitialization INSTANCE;
	private ThreadSafeInitialization() {}

	public static synchronized ThreadSafeInitialization getInstance() {
		return INSTANCE == NULL ? new ThreadSafeInitialization() : INSTANCE;
	}
}


// 이러한 점을 극복하기 위해 Double-checked Locking 기법을 사용할 수 있다.

// Double-checked Locking은, ThreaSafe초기화를 할때 메번 메소드에 할당된 synchronized 때문에
// 오버헤드가 커 성능 저하가 발생했다.
// 이를 극복하려면, 오버헤드를 줄여야 한다. 오버헤드가 발생된 원인이 synchronized 라면, 최초에 한번만 synchronized가 적용이 되고
// 이후에는 이미 생성된 인스턴스를 반환해야 할 때, synchronized가 적용이 되지 않도록 하는 것이다.

// 이때 volatile 키워드를 붙여주어야 I/O 불일치 문제를 해결할 수 있다.
// 단 JVM 1.5 이상이어야 되고, JVM에 따라 여전히 쓰레드 세이프 하지 않을 수 있기 때문에
// 사용하기를 지양하는 편이다.




// volatile
// 자바에서 여러개 쓰레드를 사용하는 경우, 각각의 쓰레드들은 변수를 메인 메모리 (RAM) 에서 가지고 오는 것이 아니라
// 캐시에 저장되어 있는 변수값을 가지고 온다.
// 하지만 비동기로 캐시에 변수값을 저장하고 사용하게 되면, 각 캐시에 저장되는 변수값이 달라질 수 있다는 문제가 있다.
// 그러므로, volatile키워드를 이용해 변수에 접근하게 될때, 해당 키워드가 할당되어 있는 것은 캐시에서 값을 가지고 오지말고,
// RAM 메인메모리에서 직접 가지고 오라는 것을 의미한다.


class DoubleCheckedLocking() {
	private static volatile DoubleCheckedLocking INSTANCE;
	private DoubleCheckedLocking() {}

	public static DoubleCheckedLocking getInstance() {
		if(INSTANCE == NULL) {
			// 위 ThreadSafe는, method에 싱크로나이즈를 걸어주었지만
			// DoubleCheckedLocking 같은 경우는 클래스에 걸어준다.
			// 즉 이렇게 걸게 되면, method를 호출하게 될때, 매번 싱크로나이즈드 때문에 오버헤드가 발생되지 않고
			// INSTANCE == NULL인 경우, 즉 처음에 널인 경우에만
			// 싱크로나이즈드의 영향을 받게 되고, 호출 시점에는 처음 끝, 모두 싱크로나이즈드의 영향을 받지 않기 때문에

			// ThreadSafe하게 된다.
			synchronized(DoubleCheckedLocking.class) {
				if(INSTANCE == NULL) {
					INSTANCE = new DoubleCheckedLocking();
				}
			}
			return INSTANCE;
		}
	}
}





// 하지만 더블체크락킹 기법도, JVM에따라서 여전히 쓰레드 세이프 하지 않을 수 있을 가능성을 가지고 있기 때문에
// 싱글톤 객체를 구현할때, Bill Pugh Solution(Lazy holder)기법을 사용하게 된다.

// 빌 퍼그 솔루션은, 멀티 쓰레드 환경에서도 쓰레드 세이프하고, Lazy Initialization을 지원하기 때문에 메모리도 객체가 필요한 시점에 적제할 수 있다는 두 가지 장점을 모두 가지고 가는 기법이다.


// 우선 이 코드의 메커니즘을 이해하기 위해서는, JVM의 클래스 로더가 언제 클래스를 로드하는지 그리고 언제 클래스가 초기화가 되는지 알아야한다.
오케이 메커니즘은 이해가 되었다.

// 이렇게 되면 static class는 outer class입장에서 내부 클래스기 때문에
// 외부참조가 되어 있지 않다. 따라서 내부클래스의 인스턴스 생성을 위해 외부 클래스가 필요로 하지 않게 되고
// 외부클래스가 GC대상에서 제외되지 않기 때문에, 메모리 누수를 방지할 수 있다.
// 일반 inner class같은 경우였으면, 외부 내부 클래스를 생성할때 외부클래스를 생성해야 하고
// 외부 참조로 인해서 외부 클래스가 더 이상 필요로 되지 않음에도 불구하고
// 즉 GC에의해서 메모리가 수거 되어야 함에도 불구하고 수거가 되지 않게 된다.
// 하지만 static inner class는 그러한 외부 참조가 없기 때문에
// 외부클래스의 인스턴스를 생성하지 않아도 내부 인스턴스를 직접 생성할 수 있다.
// 그럼 BillPughSolution이 JVM 클래스 로더에 의해서 Loading 과정을 거치게 되면
// 메모리에 적제가되고 Linking과정을 거친다음, 초기화 단계에서
// 클래스기 때문에 초기화는 메모리에 적제되는 순간 딱 한번만 초기화 하게 된다.
// 그러므로, 한번만 초기화 되는 특성을 활용한다는 것은 클래스 초기화가 쓰레드 세이프 하다는 것이고
// 쓰레드 세이프 하다는것은 동시성 문제를 해결한다는 것을 의미한다.

// 그러므로 동시성 문제를 해결하면서도, getInstance 정적 메소드를 통해서
// BillPughSolution.INNSTANCE를 가지고 오게 되고, 이때 클래스 초기화가 진행되면서 
// new BillPughsolution에 의해 할당된다.
// 르머녀 이후에 getinstance를 통해 객체를 가지고 오더라도
// 같은 객체를 반환하게 된다. 
// 즉 final로 설정되어 있기 때문에 값이 재할당되지 않게 방지한다.
// 그러므로 똑같은 객체만가지고 오게 된다.
class BillPughSolution (){
    private BillPughSolution() {}
    private static class BillPughSolution() {
        private static final BillPughSolution INSTANCE = new BillPughSolution();
    }

    public static BillPughSolution getInstance() {
        return BillPughSolution.INSTANCE;
    }
}
