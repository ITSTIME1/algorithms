import java.util.*;


class Main {
	private static BufferedReader br = new BufferedReader(new InputStreamReader(Sysetm.in));

	private static void run (){
		/*
			N이 주어짐. 최소 1 그리고 90까지 주어짐.
			8비트 최대 255. 8비트 안에서 해결이 가능.

			이친수의 개념
			이진수가 주어졌을때, 특별한 성질 조건을 만족한다면 이친수라고 정의함.

			<조건>
			1. 이친수는 0으로 시작하지 않음.
			2. 1이 두 번 연속으로 나타나지 않음.

			1번 조건은 가장 앞에 있는 숫자가 0이 아닌지를 판단하면 되므로 쉬운데
			N자리 이친수를 만들어야 함.
			즉 N = 3이라면 3자리의 이친수의 개수를 구해얗마.

			이친수는 두조건을 모두 만족해야함.
			따라서, 둘 중에 한 조건만 만족하거나, 둘다 만족하지 않으면 이친수가아님.

			예시
			N = 3
			000
			부터 시작한다는걸 의미함.
			가장 작은 수를 떠올려보면 000 = 0임.
			000 ~ 111 까지를 생각해볼 수 있음.
			4  + 2 +  1 = 7까지인 것을 알 수 있음.

			N = 4
			0000 ~ 1111 까지
			8 4 2 1 = 15

			N = 5
			00000 ~ 11111 = 31


			공통적인 것을 추출해 일반화해보면, 어떤 N이 주어졌을때 최대 N의 자리까지 모두 검사를 해야 한다는 것을 알 수 있음.
			그럼 루프를 돌때, 0부터 시작은 하지만, 최대를 어떻게 설정할지를 생각해봐야함.
			아 생각해보니까 2의 거듭제곱으로 나타내지니까 2^N 만큼 반복이 되네

			N = 3이먄, 2^3 = 8이니까 0 ~ 7까지 구현이 될거고
			N = 4이면, 2^4 = 16이니까 0 ~ 15까지 구현이 될거임.

			그럼 루프의 최대범위는 2^N승이 됨.

			다음으로, 조건을 모두 만족하는 경우를 생각해보자.
			1. 0인지 아닌지를 알 수 있는 방법.
				1) 인덱스로 0번째를 추출해서. 0인지 아닌지를 검사. (index를 범위가 아닌 바로 추출하는 것이므로 O(1))

			2. 부분문자열이 포함되는지의 여부
				1) 11이 두번 연속으로 포함되면 안되기 때문에, 11 두자리 만큼을 추가적으로 확인해봐야함.
				그러면, N자리에서 - 2 만큼 확인해봐야하기 때문에, O(N - 2)만큼 시간이 소요됨

			위 방법대로 시간복잡도를 계산하게 된다면 O(2^N * N - 2)
			시간복잡도에서 탈락인데

			1초에 1억번 연산이 가능하다는 가정하에
			2초면 2억번정도를 수행할 수 있는데

			시간복잡도상 2초에 절대 해결이 불가능한데 이건 dp programming으로 해결이 가능하다함.
			
	
		*/

	}
	public static void main (String[] args) {
		run();
	}
}
