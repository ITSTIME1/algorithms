package SortTest;
import java.util.Comparator;
/**
 * ComparableTest
 */

class Student implements Comparator<Student>{

    Student() {}    
    // Comparator는 Comparable과 마찬가지로 interface다. 따라서 Comparator 인터페이스가 소유하고 있는 추상메서드인 compare메서드를 구현해야한다.
    // 이때 compare 메서드는 Comparable의 compareTo메서드와는 다르게, 파라미터로 객체를 두개 받는다.
    // 그 이유는 Comparable의 compareTo메서드는 호출한 객체 자신과 비교할 객체를 비교하기 때문에, 자기 자신을 이미 비교하게 되므로
    // 두 개의 객체를 입력받는게 불필요하다. 하지만 Comparator의 compare 메서드는 자기 자신과 비교하는게 아닌, 두 개의 객체를 파라미터로 입력 받아 비교 하게 되므로
    // 자기 자신과 비교하지 않게 되어, 비교할 객체 두 개가 입력으로 주어져야 한다.
    // 자기 자신과 비교하지 않기 때문에, 해당 메서드를 호출할때, 객체를 이용해서 메서드를 호출한다고 하더라도, 비교할 객체는 따로 입력을 해주어야 한다는 것이다.

    // 이것이 comparator와 comparable의 차이점이다.
    // comparator를 사용하게 되면, 위에서 말했던 것 처럼 compare메서드를 호출한 객체는 사실상 아무런 의미가 없어진다. 
    // Comparable interface의 compareTo는 자기 자신과 입력 받는 비교 객체와 비교하게 되지만, Comparator의 compare메서드는 그러한 것이 아니기 때문이다.
    // 그렇다는 것은 코드를 작성할 때, 일관성이 떨어진다는 것이다. 객체가 가지고 있어야 할 책임과 역할이 모호해 진다.
    // 예를들어, 비교할 목적이 아닌 객체인데 메소드를 호출해야 한다는 것 때문에 의미도 없이 그 객체를 활용해야 한다.
    // 또는 비교할 목적이 아니게 하기 위해서 비교할 객체에서 메서드를 호출한 뒤, 파라미터로 넘겨주는 방법도 있다.
    // 하지만 두 가지 모두 일관성이 없어 보인다. 무언가. Comparator를 구현을 했고, compare메소드를 사용해야만 하기 때문에
    // 사용하는 느낌이 든다.
    // 이러면 코드 상에서는 문제 없이 비교가 되겠지만, 이후 코드를 볼때 왜 이 객체를 호출했는지 이해하지 못하는 경우도 있을 수 있다고 생각한다.
    // 즉 이 객체를 이용해서 꼭 compare를 호출해야 하나요? 와 같은 질문이 나올 수 있으며 그럴 때 마다 대답을 해주거나 주석을 달아놓을 불필요성 까지 생길 수 있다는 말이다.
    // 그럼 비교만을 위한 객체를 만들어 두면 되지 않은가? 할 수 있지만, 메모리 공간의 낭비로 이어진다. 자바는 인스턴스를 생성하게 되면 메모리 공간을 할당받게 되고
    // 해당 인스턴스를 더 이상 사용하지 않을 경우 가비지 컬렉터에 의해서 GC 되어진다.
    // 하지만 구지 GC가 되어지게끔 만들어야 할 이유는 없으며, 메모리 공간을 comparator메소드를 위해서 구지 사용해야 할 이유도 없다.
    // 만약 클래스에 여러 멤버변수들을 가지고 있다면 그 또한 메모리 공간의 추가적인 낭비로 이어지기 때문에, 어떤 특정 객체에 대해서 정렬을 한다고 했을때
    // 객체의 수가 많아지면, 객체의 수만큼 메모리 공간을 적어도 1개는 더 확보해야 한다는 것을 의미한다.
    // 그러므로 이 또한 올바르지 못한 방법이라고 할 수 있다.
    // 됐어, compare(Student o1, Student o2), compareTo(Student o1)

    // 이를 해결하기 위해서 익명 객체를 사용한다. 익명 객체라고 한다면
    // 클래스의 이름으로 따로 정의한 객체가 아니다.
    // 즉 그저 상속된 이름 없는 객체를 하나 사용하겠다는 의미가 된다.
    // 그래서 interface든 클래스든, 특정 기능을 위해서만 해당 객체를 사용해야할 필요성이 있을때,
    // 익명객체를 활용한다.
    // 그렇다면 Comparable도 익명객체를 생성해서 쓸 수 있지 않은가?
    // 물론 사용은 할 수 있지만, 우리가 원하는 비교 방식이 아닌게 된다.
    // Comparable은 자기 자신과 비교객체에 대한 대소관계의 비교기 때문에
    // Comparable에 대해서 객체를 생성하게 된다면 자기 자신은 Comparable객체가 되고
    // 그 Comparable객체와 동일타입이 아닌 Student와 비교하게 된다.
    // 그러므로 의미가 없어지게 된다는 것이다.

    // Comparator를 익명객체로 만들었을 때 그 객체의 타입은 Comparator타입이 된다.
    // 그러므로 해당 객체는 오로지 비교 부분을 위한 객체로써 관심사가 분리되어진 것을 볼 수 있다.
    // 즉 Comparator는 자기 자신과 비교하는게 아닌 두 파라미터 사이에서 비교를 하기 때문에
    // 비교하는 기능은 제공해주면서, 자기 자신과 비교하지 않는, 결국 자기가 가지고 있는 기능만 사용하게 하는
    // 책임을 가지게 되면서, 관심사의 분리가 생기는 것이다.


    // 다시 돌아와 결국 Comparable, Comparator 둘다 모두 객체에 대한 비교를 위해서 사용하는 것이지만
    // 그 쓰임이 서로 다르다는 것을 알 수 있다.
    // 그리고 관심사 분리를 위해서 Comparator같은 경우는 익명객체를 활용하여, 특정 정렬 기능을 제공해주는
    // 기능만을 따로 만들어서 사용해줄 수 있다는 것을 알 수 있다.

    // 그럼 이제, compare, compareTo의 정렬을 어떻게 이해하면 좋을지 생각해볼 필요가 있다.
    // 인터페이스를 이용해서 정렬 메소드를 오버라이드 하여 무엇이 되었든 사용한다는 것은 이해가 되었는데
    // 그렇다면, compare, compareTo의 양수 음수 0의 기준은 어떻게 정렬이 되는 것일까? 를 이해할 필요가 있다는 것이다.
    // 위에서 살펴보았던 것은, 대소관계에 의해서 양수 음수 0이 나온다는 사실만 살펴보았지, 이를 적용해 정렬이 어떻게 되는지는 알 지 못했다.
    // 따라서 지금 당장 양수 음수 0을 가지고 정렬을 어떻게 하냐는 질문에 대답을 하지 못하는 것이다.


    

    @Override
    public int compare(Student o1, Student o2) {
        // TODO Auto-generated method stub
        return 0;
    }
    
}
public class ComparableTest implements Comparable<Student>{
    // Comparable 은 interface.
    // Comparable은 인터페이스기 때문에, Comparable을 구현한다면, Comparable이 가지고 있는 추상 메서드를 모두 구현해야함.
    // Comparable이 가지고 있는 메서드는 compareTo메서드.

    // compareTo메서드는 호출한 객체 자신과 매개변수로 입력받게 되는 객체와 비교함.
    // compareTo메서드는 negative, zero, positive, 음수, 0, 양수를 반환
    // 자기 자신의 객체와 비교하기 때문에, 입력 받은 객체의 대소비교의 기준은 호출한 객체를 기준으로 결정하며
    // 그러므로 호출한 객체와 비교할 객체사이에 호출한 객체가 > 비교할 객체 크다면, 0을 리턴 ex) 7 - 4 = 3 > 0
    // 만약 0을 리턴한다면 호출한 객체 == 비교할 객체. ex) 7 == 7 == 0
    // 만약 음수를 리턴한다면 호출한 객체 < 비교할 객체 ex) 7 < 9 = -2
    // OverFlow를 조심해야함. 단순 호출한 객체 - 비교할 객체 해서도 위와 같이 나오지만,
    // int 범위가 넘어가는 연산에 대해서는, 값이 원하는 것 처럼 나오지 않기 때문에, 값의 범위가 넘어갈 수 있다면 대소 비교를 분기문을 통해서 하는게 바람직함.
    // int가 -2^31 ~ +2^31 이기 때문에, int범위 내에서 표현할 수 없게 되면, 표현할 수 있는 범위 에서 벗어나므로, 이렇듯, 값의 비교 범위가 int형 범위가 넘어갈 수 있는 경우는, 분기문을 통해서 비교해주는게 바람직함.

    @Override
    public int compareTo(Student s) {
        return 0;
    }

    public static void main(String[] args) {
        
    }
}