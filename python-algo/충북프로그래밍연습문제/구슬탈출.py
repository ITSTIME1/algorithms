import sys
import heapq
import math
from collections import deque
from itertools import permutations, combinations, product, combinations_with_replacement
input = sys.stdin.readline


# 각각의 공이 움직일 수 있는 위치를 찾고
# 만약 파란공은 왼쪽
# 빨간공은 오른쪽으로 갈 수 있을떄

# 갈 수 있는 방향을 업데이트해서 좌표를 업데이트해주면
# 서로 움직이게 되는거고
# 만약 그때 파란공이 움직일 수 있지만 구멍이라면 실패가되고
# 빨간 구슬과 파란구슬이 동시에 빠지게 되어도 실패다
# 오로지 빨간구슬만 구멍에 빠져야 성공이된다.stdin

# 구슬이 움직이지 않을 조건이 중요한데
# 1. 파란공이 'o'에 빠진경우
# 2. 빨간공 파란공 'o'에 빠진경우
# 3. 같은 칸에 있을때

# 위 세가지 경우가 아니라면 모두 움직일 수 있고
# 이때 빨간공의 움직임을 세기 위해 cnt를 움직일때마다 업데이트해주고
# 10이하로 움직여서 빨간공을 구멍을 통해 빼내지 못할경우 -1을 출력한다.
# 만약 그렇지 않을 경우 빨간공이 움직인 최소횟수를 출력한다.



# 5 5
# #####
# #..B#
# #.#.#
# #RO.#
# #####
# ##########
# #       o#
# #  R #   #
# #		 b #
# ##########

# 북, 남 쪽으로 갈 수 있다면
# 우선순위는 어디에 두어야하는가?
# 1번째 4방향중에서 O가 있는가?
# 만약 O가 없다면 
# 다른 방향을 가긴 가는데
# 그 다른 방향이 여러개라면 전부다 간다
# 이때 가기 시작할때 +1을 한다.
# 끝까지 먼저 가보고
# 더이상 갈수 없다면 거기에서 다시 방향을 탐색한다
# 그리고 다시 쭉 가본다.
# 그렇게 O지점을 찾았다면 그 길로 갔을때 몇번움직였는지를 카운트한다.


# 구슬을 찾았으면 탈출하고
# 최소의 탈출 횟수를 찾아야하기 때문에
# bfs, dfs
# 전부다 가본길의 횟수를 비교해서
# 가장 적은 길의 횟수를 리턴한다
# 이때 

# 각 길마다 움직인횟수가 10회이하여서 찾을 수 없다면


