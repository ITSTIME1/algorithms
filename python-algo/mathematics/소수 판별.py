# 기본적으로 소수의 대한 개념을 알고 있어야 되는데


# 소수란 = 1과 자기 자신만을 약수로 가진 수를 의미하고
# 그 의미는 곧 약수의 개수가 2개인 수를 의미 한다

# 그럼 여기서 약수란 = 어떠한 정수를 나누었을 때 나머지를 0으로 만드는
# 수를 그 정수의 약수라고 한다


# (1). 기본적인 소수판별 알고리즘

x = 11
def check_prime(x):
	for i in range(2, x):
		# 그 수가 2~x까지 검사했을 때
		# true 되는게 있다면 소수가 아니고
		# 예를 들어 4같은 경우 2,3까지 검사를 하는데
		# 4는 2로 나누어떨어지기 때문에
		# 소수가 아니다 즉

		# 예를 들어 16 같은 경우는
		# [2,15] 까지 니까 2,4,8 로 나누어 떨어지기 때문에
		# 1, 자기 자신을 제외하고 검사해보는 알고리즘이다
		# 1과 자기 자신을 제외하니까
		# 그 1,N 을 제외하고 나머지로 나누어 떨어지면
		# 소수가 아니기 때문에 이 방법을 기본방법으로 사용한다.
		if x % i == 0:
			return False
	return True

print(check_prime(x))



import math
# (2). 제곱근을 이용한 소수판별 알고리즘
# 해당 알고리즘은 제곱근까지만 구하면 되기 때문에
# 대칭성을 이용해 이게 가능하지만
# 만약 범위가 주어졌다면 즉 숫자 하나만 소수판별
# 해야 되는게 아니라 범위가 주어진 상태라면
# 어떤 알고리즘을 써야 할까?
def check_prime_squared(x):
	# 제곱근까지 1/2 혹은 0.5
	# 제곱근까지 확인을 하고
	for i in range(2, int(math.sqrt(x))+1):
		if x % i == 0:
			return False
	return True

# (3).에라토스테네스의 체
<<<<<<< HEAD
# 제곱근 구하는 방법을 알아야함.11,130,000
=======
# 제곱근 구하는 방법을 알아야함.
# 에라 토스테네스의 체 알고리즘 의 시간복잡도는 O(Nlog2(log2N)) 이다
# 대략 N = 1000000 이라고 할때 4초 정도의 시간이 소요 되며 4000000의 데이터를 처리가능 하다
# 하지만 N = 1000000000 10억 이상이라면 이 함수의 시간복잡도는 N * log2무한대가 되기 때문에
# 4초 이내 구하기 힘들다.
# 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다.
# 2부터 시작해서 나열된 수에서 지워지지 않은 수 중 가장 작은 2를 소수로 선택하고 2의 배수를 지운다.
# 3도 지워지지 않았기 때문에 소수로 선택하고 3의 배수를 지운다.
# 4는 지워졌기 때문에 넘어가고 5를 소수로 선택하고 5의 배수를 지운다.
# 2,3,4와 같은 과정을 반복한다.
# 반복이 끝나면 지워지지 않은 수들을 소수로 출력한다.
n = int(input())
def sieve_of_eratosthenes(n):
	dp = [True] * (n+1)
	sqrd = int(n**0.5)
	for i in range(2, sqrd+1):
		if dp[i] == True:
			# 배수들을 다 지운다
			for j in range(i+i, n+1, i):
				dp[j] = False

	return [i for i in range(2, n+1) if dp[i] == True]

print(sieve_of_eratosthenes(n))
>>>>>>> 40e89b037f95e0aeb6d935f2b4bc6bbec3821ffa
