# 그래프 or 트리 구조에서 사용된다


# 그래프 : 요소들이 서로 복잡하게 연결되어 있는 관계를 표현하는 자료구조

# 이 그래프는 정점(vertex) or (node) 와 edge 간선을 가지고 있다

# 경로중에서 반복되는 간선이 없는 경로

# 무방향그래프 (undirected graph)
# 간선의 방향이 없는 그래프를 의미하며 정점간의 양방향으로 이동이 가능함
# 무방향 그래프는 대칭적 구조를 나타내는데

# 유방향그래프 (directed graph)
# 간선의 방향이 존재하고 간선의 방향으로만 이동이 가능함.

# 인접행렬과(Adjacency Matrix) 인접리스트(Adjacency List)
# 컴퓨터에서 그래프를 표현할때는 위 두가지 경우로 나타낼 수 있는데
# 그 중에 인접행렬은(adjacency matrix)는 정점의 개수를 n 이라고 했을때
# 그때 n*n 형태의 행렬로 만들 수 있다
# 인접행렬에서 행과 열을 각각의 정점을 의미하며
# 무방향 그래프에서는 정점과 정점이 양방향으로 연결되어 있기 때문에
# 만약 [1,2,3,4]
	# [1]
	# [2]
	# [3]
	# [4]
# 위 처럼 정점의 개수가 4개이고 4*4 = 4^2 행렬로 표현이 가능하니까
# 위 처럼 만들어준다면 
# 1,1 2,2 3,3 4,4 는 자기 자신이다 즉 자기 자신한테는 간선이 존재하지 않는다면
# 이 간선의 값은 0 이 되는것이다 
# 1,1 2,2 3,3 4,4
# 1,2 = 2,1
# 1,3 = 3,1
# 1,4 = 4,1

# 2,1 = 1,2
# 2,3 = 3,2
# 2,4 = 4,2

# 대칭적으로 그래프가 그려지는 이유는 = 간선이 한방향으로만 이루어지지 않고
# 양방향으로 갈 수 있는 "무방향 그래프 이기 때문에" 1,2 의 값이 1->2로만 갈 수 있는것이 아닌
# 2->1로도 갈 수 있기 때문에
# i=1, j=2 인 곳에 값이 하나 들어가고
# i=2, j=1 인 곳에 값이 하나 들어간다면 두 정점의 개수만큼 값이 매겨지는 것이다



# 2차원 배열에 모든 정점들의 간선 정보가 있기 때문에, 
# 두 정점을 연결하는 간선을 조회할 때 O(1) 시간복잡도로 가능하다.


# 각정점의 차수를 구하게 되는것은
# i번째의 행의 값을 전부다 더하면 되므로 그것이 곧 차수가 된다
# ex) 0번빼 vertex 의 차수를 구하고 싶다고 한다면
# 0 번은 i=가 몇번째에 존재하는지 보고 만약 그게 첫번째라고 가정한다면
# i = 0 의 행인 값을 전부 다 더해준다면 그게 바로 차수 가 된다
# 차수 = 각 정점이 가지고 있는 간선의 개수
# 각 정점의 차수를 구하게 되는 것은 곧 [0,1,0,0] 행 자체가 하나의 리스트로 표현되기 때문에
# i=0인 행이 가지고 있는 리스트의 n의 개수를 다 돌아야 하므로O(n)의 시간 복잡도가 걸리게 되고
# n의 개수가 4개라면 4+4+4+4 4*4 = 16 만큼의 시간이 걸리게 되므로O(N^2) 만큼의 시간 복잡도가 걸리게 된다
# 위의 경우는 총 정점들의 차수를 구할때



# 단점
# 간선의 수와 무관하게 항상 n² 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다.
# 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n²)의 시간이 소요된다.




# 인접 리스트 (Adjacency List)

# 인접 리스트는 각각의 정점의 인접한 정점들을 "연결 리스트(Linked List)"로 표현한걸 말하는데
# 정점의 개수만큼 인접리스트가 생성된다 ex) 정점의 개수가 4 라면 0, 1, 2, 3 각각의 정점에 대해서 연결 리스트가 생성이 된다
# 헤드포인터 배열?

# 무방향 그래프의 경우 간선이 추가되면 각각의 정점의 인접리스트에 반대편 정점의 노드를 추가해야 한다.

# 인접리스트의 모든 간선의 개수의 시간복잡도는
# 인접리스트는 정점의 개수n의 비례해서 생성이 되기 때문에
# 각각의 정점이 가지고 있는 인접리스트는 헤드를 제외한 나머지 리스트의 길이이기 때문에
# 모든간선의 수를 찾으려면 일단 n만큼의 인접리스트 순회가 필요하며 한번 검사할때마다 각각의 정점이 가지고 있는 인접정점의 개수를 찾아야 하므로 그 게 곧 간선의 개수가 된다 그걸 e 라고 했을때
# O(n+e) 만큼의 시간복잡도가 걸리게 되는데 로직에 따라 시간복잡도는 더 추가 될 수도 있지만
# 모든 간선의 수를 찾는 시간복잡도는 위와 같이 걸린다고 보면 된다

# 위의 개념들이 그래프라고 한다

# 이런 그래프 개념을 활용한게 DFS, BFS 개념이다
# 이런 그래프를 탐색할때 다시 돌아가서 다시 탐색하는 개념인 backtracking 개념이 사용되는 것이다
# 그래프의 개념을 활용한게 DFS, BFS 이고 그 DFS, BFS 에서 backtracking 개념을 사용한다

# 그게 되나...


# dfs (depth first search : 깊이의 중점을 두고 탐색하는 알고리즘)

# 깊이의 우선을 둔다는건 먼저 시작점부터 해서 그 시작점의 간선을 통해 각각의 child 값에 접근해
# 그 접근한 값을 하나 선택하고 스택에서 방문했다는 처리를 하면 그 처리한 값의 child 를 또 한번 접근
# 이렇게 더 이상 정점이 없을때 까지 먼저 탐색하는 방법

# 가중치 그래프일 경우 1이 아닌 다른 가중치를 넣게 된다.
# 그렇게 가중치를 입힐 수 있음

# 우선 이 dfs 를 구현하기 위해서
# 알아야 하는건

# dfs는 구현방법이 다양 하다는거
# 1.인접행렬을 이용해서 stack 을 이용하는 방법과
# 2.인접행렬을 이용해서 재귀를 이용하는 방법


# 3.인접리스트를 이용해서 stack 을 이용하는 방법
# 4.인접리스트를 이용해서 재귀를 이용하는 방법


# 각각 한번 공부해보자


# 1. 인접행렬, stack 구조

# 백준 1260 문제를 기준으로 한번 풀어보자
# 일단 정점의 개수인 n, 간선의 개수, m, 처음 방문을 시작할, v 가 주어졌다고 했을때
n, m, v = map(int, input().split())
# 인접행렬을 이용할거니까 인접행렬은 n*n으로 만들 수 있다고 했다
# 나중에 인덱스를 1올리거나 아님 처음부터 matrix 에서 1부터 시작하는걸 맞추기 위해서
# n+1 해서 matrix 만들든 편한걸로 하면 될거 같다
# 난 n+1로 시작을 해보려고 한다
matrix = [[0] * (n+1) for _ in range(n+1)]
# 방문을 처리했다는 걸 표시하기 위해서 dp 테이블처럼 boolean 값을 만들어준다
# 이때도 1부터 시작하는걸 고려해서 n+1 만큼의 boolean list 를 만들어준다
visited = [False] * (n+1)

# 그다음에 인접행렬에 입력할 정점들을 받아주고
# 각각의 인접행렬들 ex) 1, 2 라면 2, 1에도 1을 표시해줌으로써
# 서로가 인접해있다는걸 알 수 있다
for _ in range(m):
	f, t = map(int, input().split())
	matrix[f][t] = matrix[t][f] = 1
# def dfs(matrix, vertex, visited):
# 	# 첫 시작 정점을 stack 에 넣어주고
# 	stack = [vertex]

# 	# 그럼 여기 stack 으로 다시 돌아와서 4, 3, 2 순으로 뽑아오고
# 	while stack:
# 		value = stack.pop()
# 		# 스택에서 방문처리할 정점을 가지고오고
# 		# 그 정점이 방문처리되었는지 방문처리 되지 않았는지 확인하고
# 		# 만약 방문처리가 되지 않았다면
# 		# 방문처리를 해준다
# 		if not visited[value]:
# 			visited[value] = True
# 			print(value, end=' ')
# 			# 이건 조건에 따라 다른데 이 문제에서
# 			# 방문한 정점을 작은 수부터 나열하라고 했기 때문에
# 			# matrix 의 정점 번호가 뒤에서 부터 순회한다고 가정하면
# 			# 4, 3, 2 순으로 인접행렬이 만들어져 있으며 방문처리가 되지 않은 순서대로
# 			# stack 에 쌓이게 된다
# 			# index 로 치면길이는 5지만 index 는 4부터 시작하기 때문에
# 			# c = 4, 3, 2, 1, 0 까지 진행이 된다
# 			for c in range(len(matrix[value])-1, -1, -1):
# 				if matrix[value][c] == 1 and not visited[c]:
# 					stack.append(c)
# 					# 아 pop을 이용한거기 때문에
# 					# stack pop 이란 후입선출 과정을 가지고 있기 때문에
# 					# stack 에 4, 3, 2 로 순회하게 되면
# 					# 가장 나중에 쌓이는 2가 먼저 빠져 나가게 되고
# 					# 2 또한 방문처리가 되지 않았기 때문에
# 					# 방문처리를 해준다음
# 					# 1, 2
# 					# matrix 2에 있는 값을 가지고와서
# 					# 보면 1이 인접한 리스트이면서 방문처리가 되지 않아야 하지만
# 					# matrix 2를 가지고 와보면 [0,1,0,0,1]
# 					# 이런식으로 되어있고 기존에 stack 에 추가 되었던 [4, 3]
# 					# 이 이미 있기 때문에
# 					# 우선 4부터 본다면 1이지만 방문처리되지 않았기 때문에
# 					# [4,3,4] 가되고
# 					# 그다음 3은 0이기 때문에 넘어가고
# 					# 2도 넘어가고
# 					# 1 은 인접행렬 이지만 이미 1은 초반에 방문했기 때문에
# 					# stack 에 추가할 필요가 없다
# 					# 즉 stack 에 남아있는 방문해야할 필요가 있느 ㄴ노드는 현재
# 					# [4,3,4] 가 된다
# 					# 그럼 1,2,4 가 방문 순서가 되고
# 					# [0, 1, 1, 1, 0]
# 					# 4의 matrix 정보를 뒤로 풀어서 가지고 오게 된다면
# 					# 기존에 있었던 stack = [4,3]
# 					# 에서 4건너뛰고 3 을추가해주고 [4, 3, 3]
# 					# 그리고 나서 2는 이미 방문했으니 넘어가고 1도 넘어가고 0도 넘어간다
# 					# 애당초 0 은 1을 맞춰주기 위해서 임의적으로 만든 값이기 때문에
# 					# 없는 값이라고 생각해야한다
# 					# 이렇게 되면 1,2,4,3 값으로 방문하게 되고
# 					# 3을 뽑아보면 [4, 3] 만 남게되고
# 					# 3 의 매트릭스를 가지고 와보면
# 					#  [0, 1, 0, 0, 1]
# 					# 이런식인데 4는 방문했기에 넘어가고
# 					# 3은 0 이기에 넘어가고 2도 0이기에 넘어가고
# 					# 1은 방문했기에 넘어가고 0 을 넘어가면 3 을 뽑게 되고 4를 뽑게 되서
# 					# 마지막에 stack 에 값이 하나도 남지 않게 된다
# 					# 그렇게 되면 while 반복문에서 탈출하게 된다
# 					# 만약 방문한 순서를 다른 리스트에 담아서 한번에 출력하고 싶다고하면 따로 그렇게 또
# 					# 만들어주면 되는 부분이다				
# dfs(matrix, v, visited)


# 인접행렬, 재귀(recursive)
# 뭔가 재귀로 하면 훨씬 간단해지네


# [[0, 0, 0, 0, 0],
#  [0, 0, 1, 1, 1],
#  [0, 1, 0, 0, 1],
#  [0, 1, 0, 0, 1],
#  [0, 1, 1, 1, 0]]

# [1, 2, 4, 3]
def dfs(matrix, vertex, visited):
  visited[vertex] = True
  print(vertex, end=' ')
  # c = 0, 1, 2, 3, 4

  for c in range(len(matrix[vertex])):
    if matrix[vertex][c] == 1 and not visited[c]:
      # dfs(2)
      # dfs(4)
      # dfs(3)
      dfs(matrix, c, visited)
dfs(matrix, v, visited)

 