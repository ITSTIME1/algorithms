# 다이나믹 프로그래밍 (동적 계획법)

# 한번 계산한 문제는 다시 계산하지 않도록 하는 것.

# 다이나믹 프로그래밍 조건은
# 큰 문제를 작은 문제로 나눌 수 있는 조건
# 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도
# 큰 문제에서도 동일한 값이다.

# an = an-1 + an-2 , a1 = 1, a2 = 1


# 다이나믹 프로그래밍에서는 메모제이션 기법이 사용되고
# 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여
# 탑다운 방식과 반복문을 사용해서 작은문제부터 차근차근 풀어나간다고하여
# 보텀업 방식이 있다


# 탑다운 방식 ( 메모제이션을 이용 )

dp = [0] * 100

def fibo(x):
	
	if x == 1 or x == 2:
		return 1

	# 처음 계산하는게 아닌 이미 계산되었던
	# 값을 그대로 리턴
	if dp[x] != 0:
		return dp[x]
	# 아직 계산하지 않은 문제라면 점화식에 따라
	# 피보나치의 결과를 반환
	dp[x] = fibo(x-1) + fibo(x-2)

	return dp[x]

print(fibo(5))


# 보텀업 방식

N = 5
# dp 테이블을 정의 한 번 계산된 값을 저장하기 위한 용도

dp = [0] * 100

# dp[1], dp[2] == 1 첫번째 항과 두번째 항은
# 항상 1 로 초기화
dp[1] = 1
dp[2] = 1

# 바텀업 방식으로 작은 문제부터 쭉 구해나감
# 그랬을 때 내가 구하고자 하는 N 번째 항의 값을 구할 수 있게 만듬.
for i in range(2, N+1):
	dp[i] = dp[i-1] + dp[i-2]



