# 다익스트라를 개념과 함께 정리해서 구현해보자.
# 시작 노드를 먼저 알려주어야 한다는건데
# 다익스트라 알고리즘이라는 것은
# 기본적으로 그래프가 주어지고
# 특정하 노드에서 출발을 할 때 그리고 그 노드에서부터 방문하지 않은 다른 노드들과의
# 각각의 최단경로를 구해주는 알고리즘이다.

# bfs는 항상 빠른 경로를 통해 목적지 까지 달성하는데
# 비용이 없다.
# 비용이 없다는건 가중치가 전부 동일하다는 것이고
# 다른 노드까지 가는데 어떠한 거리 계산이 필요가 없다는것이다
# 즉 모든 경로를 가는데 동일한 힘 또는 비용 시간이 들기 때문에
# 거리와 계산, 힘에 상관없이 무조건 한 목적지에 대해서 먼저 도착하기 만 하면된다.
# 그렇기 때문에 dfs는 최단경로를 보장할 수 없고 bfs가 최단경로를 보장하는데
# 위와 같은 이유를 생각하면서 한 목적지에서 최단경로를 찾기 위해 넓게 넓게 탐색하니
# 만약 비교적 가까운 거리에 있다면 bfs가 가장 먼저 찾아낼 확률이 높아진다.
# 따라서 bfs가 최단경로를 찾을 수 있다.

# 그렇다면 가중치가 있는 그래프라면 어떨까
# 가중치가 있다는건 각 노드로 갈때 비용 혹은 시간, 힘이 필요하다는 것이고
# 만약 가장 적은 횟수 또는 비용, 또는 시간을 들여서 다른 노드까지 가고 싶다고 했을때
# bfs는 이런걸 고려하지 않는다. 고려하지 않는다는것은
# 비용에 따른 혹은 시간에 따른 혹은 그 외 다른 것들에 따른 것들에 상관없이 무작정 먼저 도착한게 가장빠르다는 논리기 떄문에
# 우리가 원하는 가장 적은 비용을 혹은 가장 적은 힘을 가장 적은 시간을 위해서 구한게 아닌 게 된다.
# 따라서 무작정 해당 노드에 먼저 도착한게 가장 빠르지 않을 수 있다는 뜻이된다.
# 목적 자체가 시간, 비용, 힘을 최소화 하기 때문에
# 만약 bfs가 찾은 길이 10-5-4 가 들어가는 것이라고 해보자
# 물론 bfs가 찾은 길은 최단경로가 된다. 가장 단거리로 도착하는 길이라고 가정하자
# 그랬을때 bfs는 비용을 생각하지 않기 때문에 그저 우선적으로 도착한 것만 보장했다. 따라서 비용, 시간을 고려하지 않은 최단 경로가 된다.

# 하지만 우리가 원하는 경로자체가 비용, 혹은 시간 등을 가장 적게 사용해서 갈 수 있는 길을 찾고 싶다고 한다면
# 위 bfs알고리즘은 해당 조건을 만족할 수 없을 수 있다. 운이 좋아서 그걸 만족할 수 있겠지만
# 대부분의 경우에는 만족할 수 없을 것이다
# 만족하는 경우라면 위 처럼 위 경로로 갔을때가 가장 최적일떄이다.
# 하지만 그렇지 않은 경우를 생각해본다면 10-1-1-1 로 갔을때
# 최적이 될 수 있다. 이러면 10+5+4 = 19만크의 힘을 들여서 혹은 시간을 들여서 도착한 경로보다
# 10 + 1 + 1 + 1 + 1 = 15만큼의 힘을 들여서 도착한것이 더 최적의 경로가 되기 때문이다.

# 만약 이걸 그저 비용이라고 하면 헷가리니 거리라고 해보자
# 19km를 가야 했던 길이 bfs에서는 최선의 길이라고 했다면
# 다익스트라에서는 15라는 길을 찾아냈다. 그렇다는건ㄱ
# 거리가 더 짧은 방법이 19로 가는 방법말고도 존재한다는 것이고
# 그것이 바로15로 가는 길임을 보여준다.

# 따라서 어떠한 비용에 따라 최단 경로를 구할 떄는 bfs로 구할 수 없을 수 있다.

# 그렇기 떄문에 현재 경로에서부터 만약 다른 경로까지 최소한의 비용을 들여 도착하고 싶다면
# 비용을 고려해야 될 것이다.
# 그럴때 사용하는 알고리즘이 바로 다익스트라이다.
# 다 익스트라를 고려한다면 현재 정점에서부터 갈 수 있는 거리들 중 가장 짧은 거리를 택할것이고
# 만약 3번까지 가고 싶을때 1번에서 시작해서 4번을 거쳐 3번으로 가는것
# 1번에서 2번ㅇ르 거쳐 3번으로 가는 것 둘 중 어떠한 경로가 가장 짧은지를 계산하는것이다,
# 만약 1번에서 3번으로 바로 가는 길은 5라는 비용이 들었는데
# 1에서 4번을 거쳐 3번으로 가는 비용이 4라는 비용이 들었다면
# 해당 경로가 더 적은 비용을 구햇다는걸 알 수 있다.
# 따라서 이 경로가 더 최단 경로가 되니ㅡㄴ 것이다. 3번으로 가기 위한
# 비용으로 보여주지 않는가 1번에서 3번으로 바로 갈때 50만원이 드는데
# 약간 우회해서 가서 1번에서는 10만원 내고 4번에서 3번으로 갈때 30만원만내면
# 10만원을 덜 내기 때문에 더 적은 비용을 내고 3번까지 도착하는 것이지 않나.
# 그랬을때 가장 적합한 경로를 찾았다고 할 수 있다.
# 그럼 가장 짧은 경로로 온 것에서부터 또 다른 경로로 가기 위한 최단 경로를 찾는다.
# 이때도 마찬가지로 3번에서 다른 경로로 가기 위한 최단 경로가 항상 연결된 노드로 바로 가는것이 최단경로가 아닐 수 있다.
# 따라서 현재 경로에서 갈 수 있는 가장 짧은 노드를 탐색한다.
# 마찬가지로 우리 의 목적지가 6번이라고 한다면
# 우리의 목적지 까지 3에서 5번을 거쳐 6번으로 가는 방법이 존재하고
# 3에서 바로 6번으로 갈 수 있는 비용이 존재한다고 했을때 이때도 마찬가지로 3번에서 5번을 거쳐 6번으로 가는 비용이 3번에서 5번으로 가는 비용보다 더 적은 비용을 들여서가게 된다.
# 그렇다는건 3-6버능로 가는 경로보다 3-5-6으로 거쳐 가는 경로가 더 최적의 비용을 들여 가는 최단경로라는 걸 알 수 있다.
# 따라서 방문하지 않은 곳을 방문해서 해당 노드에 도착했을때
# 비용이 이전 비용보다 더 적은 비용으로 갱신이 가능하다면 그 비용으로 갱신을 하게 되는다.
# 그렇게 했을때 가장 빠른 경로로 온 경로를 이어보면 가장 최적의 경로가 되는것이다.
# 매순간 최적의 경로를 찾기 위해 탐색해왔고 마지막까지 와서도 최단경로를 찾은 것이기 때문에
# 어떤 경로로 오더라도 매순간 찾은 최단경로보다 빠른 길은 존재하지 않는다.


# int형이 표현할 수 있는 최대수는 약 21억 정도기 때문에
# 무한대를 표현할 수를 약 10억정도라고 가정해도 무한적으로 표현할 수 있다.
INF = int(1e9)

# 노드의 개수와, 간선의 개수를 입력을 받는다.
n, m = map(int, input().split())

# 시작노드를 입력받는다.
start = int(input())

# 각 노드에 연결되어 있는 노드에 대한 정보를 담을 리스트를 만든다.
graph = [[] for i in range(n+1)]

# 해당 노드를 방문했는지 하지 않았는지를 확인하기 위해서 visited 변수를 통해서 확인한다.
visited = [False] * (n+1)

# 최단 거리 테이블을 모두 무한으로 초기화한다.
# 이때 최단거리를 저장하기 위한 목적으로 distance 테이블을 활용한다.
# 최단경로는 다른 경로에 의해서 새로 갱신될 수 있다. 즉 이전에 알고 있었던 거리가 최단거리라고 알고 있었는데
# 그게 아니라 여기까지 오는데 더 좋은 비용을 혹은 더 적은 비용을 혹은 더 최대비용을 내서 올 수 있다 라는 즉 조건에 맞는 경로가
# 더 있으니까 이걸로 갱신해. 라고 하는 의미에서의 테이블이라고 보면 편할 것 같다.
distance = [INF] * (n+1)

# 모드 간선의 대한 정보를 입력받는다.
# 즉 어떤 노드가 어떤 노드로 이어져있고, 그 노드로 가기 위해서 어떤 비용을 들여서 가야하는지를 알기 위한
# 정보라고 생각하면 된다.
# 이러헥 한다면 어떤 노드에서 어떤 노드까지 이어져 있고 그 떄의 비용을 알 수 있기 떄문이다.

# 이때 어떤 노드와 연결되어 있는지는 간선의 개수로 받는다.
# 이유는 한개의 간선에 두개의 노드가 연결되어 있기 때문에
# 어떤 노드가 연결되어 있는지는 해당 간선의 개수로 알 수 있다.
for i in range(m):
    # a는 b와 연결되어 있고 그때 비용을 c라고 하자
    # 1번 노드부터 시작한다고 한다면 n+1을 통해서 그래프의 개수를 맞춰주자.
    # 그게 구현하기 편할 수 있기 때문이다.
    # 만약 그렇게 구현하지 않고 n개의 개수로만 구현하게 된다면
    # n-1로 인덱스에 접근하게 된다. 그럼 매번 탐색할때마다 n-1을 작성해서 접근해야 되기 때문에
    # 효율적이지 않다. 따라서 받아온 번호 그대로 사용하기 위한 것이라면 번호를 맞춰주는 것이 좋다.
    
    # 만약에 a-b로 가는 것도 주어지고 b-a로 가는것도 주어진다면 구지
    # 두번 인덱스에 넣을 필요 없지만
    # 만약 둘중에 하나만 주어진 상황이라면 하나로 두개가 연결되어 있는걸 표현해야 되기 떄문에
    # graph[b].append((a, c))
    # 위와 같은식이 하나더 필요하게 될 것이다.
    a, b, c = map(int, input().split())
    graph[a].append((b,c))


# 그럼이제 방문하지 않은 노드 중에서 가장 거리가 짧은 혹은 비용이 적은 노드를 찾는다.
def get_samllest_node():
    # 처음 무한대 값을 넣어주는 이유는
    # 해당 값보다 더 작은 값을 차기 위해서 0을 넣을 수는 없지 않은가.
    # 즉 그래프 상에 있는 어떠한 노드들 보다 큰 값으로 설정해야 가장 작은 노드를 찾기 수월하게 된다.
    # 만약 최소 비용이 0인데 어떠한 노드들도 0보다 작지 않다면 내가 최소비용을 들여서 갈 수 있는 길이 없지 않은가.
    # 어딜 가려고 해도 최소비용을 내서 갈 수가 없게 되니까
    min_value = INF
    
    # 이제 거리가 가장 짧은 노드를 반환하기 위해서 index 라는 변수를 선언해준다.
    index = 0
    
    # 이제 이 거리가 가장 짧은 노드를 반환하기 위해 현재 노드에서 나를 제외한 나머지 노드들을 탐색한다.
    # 일단 이걸 이해하기 위해서 다익스트라를 먼저좀 봐야겠다.
    # 따라서 여기에서는 가장 짧은 노드를 찾게 될거고 그 짧은 노드라는것은
    # 무한대는 어짜피 짧은 노드가 될 수 없으니까
    # 이제껏 가장 짧은 노드로 갱신되어 있는걸 찾게 되면된다.
    # 모든 정점에 대해서
    # 선형탐색
    for i in range(1, n+1):
        # 현재 거리가 지금까지 알고 있었던 거리보다 작고 방문하지 않은 곳이라면
        # 즉 방문하지 않은 곳들중에서 거리가 가장 짧은 것을 반환한다.
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    # for문을 통해서 거리가 가장 짧은 것을 반환을 하게 되고
    # 그럼 이제 그 노드부터 또 검사한다.
    return index

def dijkstra(start):
    # 현재 시작하는 노드에 대해서는 거리가 0이다.
    # 왜냐하면 자기 자신한테 가는 비용이니까#
    # 만약 이걸 무한대나 나와 인접한 방향의 비용보다 크게 잡는다면
    # 내가 갈 수 있는 곳이 없게 된다.
    distance[start] = 0
    # 그리고 현재는 방문했다는걸 알려준다.
    visited[start] = True
    
    # 현재 나와 인접한 노드들을 확인해보면서
    for j in graph[start]:
        # j[0] = 나와 인접한 노드의 번호
        # j[1] = 나와 인접한 노드의 비용
        # 해당 거리의 비용을 우선 초기화한다.
        # 즉 현재 start라는 가려고 하는 정점에서 해당 거리까지 가기 위한 거리를 갱신해둔다.
        distance[j[0]] = j[1]

    # 여기까지 했다면 나와 인접한 거리들을 갱신했다.
    # distance는 거리를 갱신하기 위한 테이블이기 떄문에
    # 그 거리를 갱신하기 위한 테이블을 내 기준에서 갔을때의 비용으로 계산되어진 거리값들이다.
    
    # 그럼 이제 시작 노드를 제외한 전체  n - 1 개의 노드에 대한 반복을 하게 될건데
    # 현재 최단 거리가 가장 짧은 노드부터 즉 distance 거리가 가장 짧은 노드를 가져 온다는 것이고
    # 이는 distance에는 현재 start에서 갱신된 값들을 제외하고 전부다 INF무한이다.
    # 따라서 갱신된 값들보다 항상 나머지는 크기 떄문에
    # 현재 내가 방문한 지점들과 이전에 방문했던 값들을 살펴보면서 가장 짧으 노드를 찾는다.
    for i in range(n-1):
        # 가장 거리가 짧은 노드를 알게 되었으니그 
        now = get_samllest_node()
        # 그 노드를 우선 방문처리해준다.
        visited[now] = True
        # 그리고 이 노드와 연결된 다른 노드들을 확인하는데
        # 이 노드와 인접한 노드들을 확인해볼건데
        # 새로운 노드에 방문하기도 하고
        # 이전에 방문했던 노드들을 갱신할 수 도 있다.
        # 만약 새로운 노드에 방문한다는건 INF 값이나 거쳐온 값이 더 작은 경우를 말한다.
        # 그럴때는 당연히 더 적은 비용을 가진 경로로 갱신을 해주면 된다.
        # 이후 이전에 방문했던 노드들을 갱신할때에는
        # 이전에 갱신해놨던 값이 저장되어 있기 때문에
        # 그 저장되어 있는 값보다
        # 현재 노드의 비중을 거쳐서 그 노드까지 가는데 걸리는 비용의 합산이
        # 현재 노드에 저장되어 있는 것보다 더 작게 된다면
        # 거리를 갱신하게 된다. 더 적은 거리로
        # 비용만 계산했지 방문은 안했기 때문에
        # 그곳을 방문하지 않았을때 현재 노드를 거쳐서 해당 노드의 비용을 더해서 그곳까지 도달한 값이
        # 현재 그곳에 저장되어 있는 값보다 작게 된다면
        # 더 작은 값으로 갱신한다.
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 방문하지 않은 거리를 다시 가지 않는이유는
            # 방문이 도이ㅓㅆ다는건 항상 그 곳은 최선의 거리로 갱신이 되어 있다는 걸 의미하기 때문이다
            # 따라서 갈 필요 가 없다.
            if not visited[j] and cost < distance[j]:
                distance[j] = cost
    
    
        

# 다익스트라를 사용해서 첫번째 노드부터 시작해본다.
dijkstra(start)
    
    
    

