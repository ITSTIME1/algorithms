# 다익스트라의 O(N^2)을 구현해보자.

# 다익스트라의 O(NlogN)을 구현해보자.


# 다익스트라의 알고리즘은 현재 노드에서 각기 다른 노드들 사이의 비용이 가장 적은 곳을 선택한다.
# 이때 비용은 시간, 힘, 등 다양한 가중치 값으로 표현될 수 있으며, 다익스트라에서 가중치를 기준으로
# 이전 비용이 기록되어 있을때, 현재 노드를 거쳐 그 노드를 거쳐가는 비용이 기존 비용보다 더 작게 된다면
# 비용을 갱신한다. (비용을 교체한다.)
# 이때 비용을 갱신한다는 이전보다 더 적은 비용 혹은 시간, 힘을 사용해서 올 수 있는 경우들이기 때문에
# 다익스트라 알고리즘을 사용하는 목적 최소 혹은 최단 경로를 찾기 위함이므로
# 즉 가중치의 비용이 작은 것을 찾는게 목적이기 때문에 해당 경로로 갱신한다.
# 다익스트라 알고리즘을 통해서 각 노드가 갱신이 될때 항상 가장 짧은 값으로 갱신이 되므로
# 이미 방문 처리가 되어 있는 노드는 가장 짧은 노드를 가지고 있다고 생각하면 된다.
# 이를 가장 쉽게 이해할 수 있는 방법이라면 만약 첫번째 노드에서 3개의 노드(인접노드)를 탐색했을때
# 이때 탐색하는 목적을 비용을 갱신하는데 목적을 둔다.
# 그랬을때 처음에는 모든 값들이 INF 무한대 값으로 들어있기 떄문에
# 현재 갱신될 가중치값은 해당 노드에서 가고자 하는 인접 노드들의 값으로 초기화가 된다.
# 그리고 나서 그 갱신된 가중치 값들 중에서 가장 작은 비용을 가지는 노드를 방문을하고
# 그 방문한 노드에서 인접한 노드를 또 한번 거리 계산을 통해 갱신을 할때
# 현재 갱신된 거리에서 방문한 노드에서 그 노드까지 가는 가중치를 더했을때
# 즉 현재 방문한 거리를 거쳐 그 인접한 노드를 갈때의 가중치의 합이 기존에 가지고 있던 가중치 보다
# 작다는 말은 현재 해당 노드를 거쳐 인접 노드까지 가는 거리가 훨씬 비용이 덜 든다는 얘기가 되므로
# 앞서 말했던 다익스트라의 목적을 생각해보면 가장 작은 비용으로 계속 해서 갱신을 시킨다.
# 그래서 항상 작은 값으로 갱신이 되며 작은 값으로 갱신이 될때마다 그 노드에서도 검사를 진행해야 되기 때문에
# 비용이 우선적으로 작은 것부터 차례로 계산한다.
# 가장 가까운 경로라는거 자체가 비용이 가장 적은 걸 말하며 비용이 가장 적은걸 거쳐서 온다면
# 그게 가장 적은 비용을 들인 최단 경로가 되기 떄문이다.
# 8+1+1 만큼 들여 온것보다 7+1+1 만큼 들여온 경로가 더 비용을 줄일 수 있기 때문에
# 그때그때 마다 매 순간 최선의 선택이라는 것은 가장 비용이 적은 노드를 선택하는데 있어서
# 그리디 알고리즘으로 볼 수 있으며 작은 문제가 즉 매 순간 최선의 비용을 선택하는데 있어
# 마지막까지 최선의 비용을 선택하게 만드는 큰 문제 안에 작은 문제로 풀어나가는 다이나믹 프로그래밍이라고 볼 수 있다.

# 다익스트라의 알고리즘은 한 정점에서부터 다른 정점까지의 최단경로를 구하는데 있어서 매울 효율적이라고 볼 수 있고
# BFS의 최단경로와 차이점이 무엇일까 직관적으로 생각해본다면
# BFS또한 비 가중치 그래프 즉 가중치가 없는 그래프에서 사용할때 최단경로를 보장한다.
# 앞써 BFS와 DFS의 최단경로를 찾는데 있어 BFS가 왜 최단경로를 보장하는지에 대해서 작성한 바 있다.
# 그럼 BFS와 다익스트라 모두 최단경로를 찾는데 사용되는 알고리즘들인데 차이가 무엇일까?


# 우선 가중치, 비가중치 여기서부터 생각해보면 좋다.
# 가중치는 말그대로 어떠한 노드로 갈때 드는 비용이 있다는 얘기가 되며
# 비가중치라는건 그러한 비용들이 존재하지 않거나 혹은 모두 같은걸 의미한다.
# 따라서 비가중치 그래프에서 어떤 노드로 갈때 모든 간선들의 이동 비용이 같기때문에
# 어떠한 경로로 갔을때 최소비용이 들어 도착하게 되는지를 구하는 목적이 아니다.
# 이 말인 즉 가중치가 없기 때문에 비용이 적은 경로를 찾는게 무의미하며
# 그렇게 찾을 수도 없다. 오직 BFS는 비가중치 즉 가중치가 없을때 항상 빠르게 그 지점까지 도착하는데 목적이 있다.

# 반면 다익스트라 같은 경우는 최소비용을 고려하여 즉 가중치 값을 고려하여 목적지에 최단경로로 도착하는데 목적이 있기 때문에
# 서로 다른 목적을 지니고 있다고 볼 수 있다.
# 우리가 BFS로 최단경로를 구할때 가중치 값을 계산해서 구했는가?
# 아니다 혹시라도 visited[nx][ny] = visited[x][y] + 1 이라는 코드를 많이 봐왔을텐데
# 이는 비용을 계산하는 코드가 아니라 현재 경로로 이동할때 얼만큼 이동했는지 즉 도착지점까지
# 가장 최소한의 경로로 도착해야 된다라는건 가장 적은 경로를 거쳐서 와야 된다는걸 의미하기 때문에
# 결국 '비용 혹은 가중치'를 고려하는게 아니라 이동경로의 횟수를 의미한다고 봐야한다.
# 그렇다는건 비용을 고려하여 최단경로를 구한게 아니라는 것이다.

# 단순 거기까지(어딘가) 도착하기 위해서 거쳐가야 하는 이동경로가 가장 짧은 구간을 의미한다는 것이고.

# 다익스트라에서 최소비용을 통해서 도착하게 만든다는 건 곧 가장 최소한의 이동경로가 아니라.
# 항상 그때의 최소비용을 고려하여 가중치를 고려해서 간다는 걸 의미한다.

n = 9
INF = 1e9
visited = [False] * (n+1)
distance = [INF] * (n+1)

def get_smallest_node():
    # 이 함수의 목적은 가장 짧은 노드를 선형적으로 탐색해서
    # 그래프 상에서 가장 비용이 적은 노드를 우선적으로 계속 선택하겠다는 의미가 된다.
    # 따라서 방문한걸 제외하고 방문하지 않은 노드들 중에서
    # 가장 비용이 적은 곳을 찾는데 목적이 있는 코드라고 볼 수 있다.
    # 처음 값을 INF로 두는 이유는
    # 매순간마다 가장 비용이 적은 노드를 선택해야 하는데
    
    # 처음에 찾을때 그 가장 작은 노드를 찾기 위해서
    # 얼만큼의 수가 커야하는지 모른다.
    # 따라서 처음에 INF값을 대입함으로써
    # 가장 작은 값을 찾을 수 있다.
    # 그러면 가장 작은 값들로 초기화가 되면서
    # for문을 다 돌았을 때는 가장 작은 인덱스 즉 노드만 반환되게 될 것이다.
    min_value = INF
    
    # 나를 제외한 모든 노드들에 대해서 검사한다.
    # 나는 다익스트라 알고리즘을 통해 방문이 되어 있게 되므로
    # 방문을 하지 않은 곳들 중에서만 찾게된다.
    # 그랬을때 현재 가중치 값이 가장 작은걸 찾아야 되기 때문에
    # 가중치의 값을 저장하고 있는 테이블에서 현재 노드의 가중치값이 
    # 지금까지 찾은 가중치들보다 더 작다면 갱신한다. 이때도 마찬가지로 아직 방문하지 않았다는 조건이 필요하다
    # 이렇게 하면 가장 작은 값을 계속해서 비교해 나갈 것이므로
    index = 0
    for i in range(1, n-1):
        # 이런 식으로 아직 방문하지 않고 현재 가중치 값이 지금까지 찾은 최소비용보다 작은 값일경우
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index= i 
            
    
    # 이렇게 한다면 현재 까지 가장 작은 가중치 값을 가진 노드를 찾게 된 것이다.
    return index


def dijkstra(start):
    # 시작 노드에 대해서 초기화를 진행해준다.
    distance[start] = 0
    visited[start] = True
    
    # 가중치값을 초기화해준다
    for i in graph[start]:
        # a->b 로갈때 c라는 값이 든다는 테이블이 있다고 가정하자
        # 반대로도 적용해준다면
        distance[i[0]] = i[1]    
        distance[i[1]] = i[1]
        
    # 시작 노드를 제외하고 즉 다른 노드들을 검사해서 가장 작은 녿르ㅡㄹ 찾는다.
    for i in range(n-1):
        # 이때 가장 비용이 적은 노드를 찾게 되었으니 그 노들르 방문처리해준다.
        current = get_smallest_node()
        visited[current] = True
        # 그 현재 비용이 가장 작다고 한 곳의 노드에서 인접한 곳들의 값들을 검사하면서
        # 더 적게 든 경로라면 갱신해줄것이다.
        # 마찬가지로 그 곳이 방문이 되어 있는 곳이라면 이지 최소값으로 갱신이 되어 있는 곳을 의미한다.
        # 따라서 갱신이 될 필요가 없어진다.
        for j in graph[current]:
            cost = distance[current] + j[1]
            if cost < distance[j] and not visited[j]:
                distance[j] = cost

                
# 그럼 이러한 다익스트라 알고리즘으로
# 최소 경로를 도착했는지 볼 수 있다.
# 그럼 거리 테이블에는 항상 최소거리로 갱신된 값만이 남게된다.

for i in range(1, n+1):
    if distance[i] == INF:
        break
    else:
        print(distance[i])
        
        
# 위와 같은 다익스트라 알고리즘 같은 경우에는 시간복잡도가 O(N^2)이다.
# 따라서 노드의 개수가 많다면 시간초과가 발생될 가능성이 있기 때문에
# 우선순위 큐를 이용해 시간복잡도를 줄여볼 수 있다.


import heapq

def heapsort(iterable):
    h = []
    result = []
    
    # 모든 원소에 대해서 힙 리스트에 넣어준다.
    for value in iterable:
        heapq.heappush(h, value)
    
    # 힙에 삽입된 모든 원소를 차례대로 꺼내서 담는다.
    # python 에서는 기본적으로 우선순위 큐가 최소힙으로 구성되어져 있기 때문에
    # 아래와 같이 구성할 수 있다.
    for i in range(len(h)):
        result.append(heapq.heappop(h))
    
    
    
    
def heap_dijkstra(start):
    q = []
    # 큐에다가 현재 시작 노드의 가중치와 함께 노드를 튜플 형태로 넣어주게 되면
    # (비용, 노드)
    # 힙에서는 튜플 첫번째 원소를 기준으로 우선순위를 정하기 때문에 아래와 같은 형태로 구현한다.
    heapq.heappush(q, (0, start)) 
    
    # 처음 시작하는 거리를 0 으로 초기화 해준다.
    distance[start] = 0
    
    # 큐가 없어질때까지 모든 경로를 다 탐색해볼 것이므로
    while q:
        # 가장 비용이 적은 노드에 대한 정보를 꺼낸다
        # 이때 정보는 비용, 노드로 구성되어져 있어
        # heap에서 꺼냈을때 아래와 같이 받을 수 있도록 구현한다.
        dist, now = heapq.heappop(q)
        
        # 이렇게 하면 현재 우선순위가 가장 낮은 (비용이 가장낮은)
        # 노드를 꺼낼 수 있게 된다.
        # 만약 현재 꺼낸 노드의 비용이 
        # 이미 기록되어 있는 현재 노드의 비용보다 크다면 갱신할 필요가 없다.
        if distance[now] < dist:
            continue
        
        # 이제 현재 노드와 연결된 다른 노드들을 확인한다.
        
        
        for i in graph[now]:
            # 현재 갱신되어져 있는 현재까지의 노드의 비용 + 인접한 노드까지 가는데 비용의 합이
            cost = dist + i[1]
            
            # 만약 그 비용이 현재 기록되어져 있는 인접하 노드의 비용보다 작다면 갱신한다.
            # 갱신했을때 해당 노드를 힙에 다가 넣고
            # 그 노듣르 가운데 또 가장 적은 비용의 노드를 뽑을 수 있게 만든다.
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))
            

                
            
        