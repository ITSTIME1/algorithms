# 우선 별찍기 - 10번 문제를 풀려면 재귀함수에 대해서 알아보자

# 재귀(recursion) 자기 자신을 반복적으로 호출하는 걸 말한다.
# 어떠한 특정한 조건을 명시해주지 않는다면 무한적으로 호출하기 때문에

# 무한적으로 호출하는걸 막기 위해 특정 조건을 걸어준다.

# 예를들어 합을 구하는 함수를 구한다고 해보자


# 먼저 n을 입력받는다 만약 5를 입력했다고 가정해보자

# 그럼 sum함수에n을 파라미터로 받고있으니 n의 값은 현재 5>0 큰 상태이다.

# 그럼 합계를구해야하기 때문에
# 5+4+3+2+1
# 의 순서대로 구할 수 있을것이다.
# 그럼 이렇게 생각해보자
# 5를 입력했으니 0보다 작거나 같다면 합계를 더해서 올려주는거다

# 즉 5를 호출한다면 0보다 크기 때문에 5+(5-1)의 형태로 반복호출하게끔 만들어준다는 것이다.
# 이렇게 한다면
# sudm(4)값이 파라미터로 들어가게 되고
# 4 > 0보다 크기 때문에
# 4+(4-1) 형태로 호출되게 된다.
# 이런형태로 반복적으로 호출하게 된다면
# n이 0인순간이오는데
# 0인순간에서 n을 그대로 리턴해준다면
# 마지막인 1+0 에서 0값이 리턴되어 1이 될것이고
# 그럼 sum(1) 의 값인 1+0을 리턴하게 되어 = 1을 리턴하게 된다
# 그럼 이전의 호출했던 sum(2)는 2+1이기 때문에 1의 값인 1을 더해 총 3을 리턴하고
# 이전 호출했던 sum(3)에서는 3+2를 호출했기 때문에 3+3 이 되어 6을 리턴하게 된다.
# 위의 규칙에서 보았듯이
# 이전 호출되었던 값들이 다시금 위로 올라가면서 값을 던져주는형태이다.

# 그림으로 상상해본다면
# 축구선수 5명이 있다고 가정해보자
# 그럼 각각의 번호를 1, 2, 3, 4, 5라고 붙였을때
# 내가 5번축구선수라고 가정하고 난 4번한테공을준다
# 그럼 4번은 3번 3번은2번 2번은 1번한테공을준다
# 이때 1번은 더 이상 공을 줄 곳이 없기 때문에 (필요시 로직에따라 달라질 수 있음)
# 여기서 1번은 더이상 공을 줄 곳이 없다 == 이 뜻은 재귀의 끝부분에 도달했다라고 생각할 수 있다.
# 그렇다면 1번은 "줄 사람은 없어도" 다시 "돌려줄 사람은 있다."
# 누구? 바로 2번 물론 3, 4,5번한테는 줄 수 없다는 가정하다
# 만약 3, 4, 5번한테줄 수 있다면 따로 재귀조건을 걸어 1번이 공을 더 이상 줄 곳이 없을때
# 특정한 선수한테 주게끔 만들면 된다.

# 하지만 여기서는 그게 아니기 때문에

# 2번한테 돌려줄 수 있다고 한다면
# 1은 오케이 공하나 더가져가 하면서 공을 하나 더 얹어준다
# 그럼 2번은 처음에 1번한테 공을 한개만 넘겨준 상태였다.

# 하지만 1번의 선수는 인심써서 공을한개더주어 1+1 = 2 총 공의 개수는 2가 된것이다.
# 그렇게 된다면 2번이 다시 받은 공의 개수는 총 2개가 된 것이고
# 2번은 다시 1번한테 줄 수 있지만 그렇게 주지 않고 3번한테 준다 (물론 여기도 필요에따라 로직을 조정할 수 있다.)

# 1번이 하나더 준게 빡쳐서 2번도 3번한테 하나더얹어준다 2+1 = 3총 3개를리턴해준다.
# 그럼 3번은 3개를 받게 되고 4번은 또 3번의 화의 불똥튀겨 4개를 받게된다
# 이렇게 5번은 5개를 받게 되어 공의 총 개수는 5가 된다는 것이다.

# 이걸 구현해본다면

# n이 축구선수라고 가정한다면 5번축구선수부터 시작할거다.
# 5번 축구선수는 1번 축구 선수가 아니기 때문에
# 다음 4번한테 축구공하나를 얹어서준다.

def gong(n):
    if n == 1:
    	print("{%d}선수 공의 개수 : {%d}" % (n, 1))
    	return 1
    else:
        goCnt = gong(n-1) + 1
        # 그럼 goCnt 에서는 공의 개수를 반환받았으니 현재 선수의 공의 개수는 내가 보낸 선수의 공의 개수의 +1 을 한다면
        # 현재 내가 받은 공의 개수를 알 수 있지.
        # 때문에 goCnt에서는 이전공의개수+1개의 공을 받환받은 값을 goCnt 변수에 저장하고
        # 아래 프린트문에서 지금 재귀의 위치 = 현재 선수의 n의 goCnt 값을 출력할 수 있는거지.
        print("{%d}선수 공의 개수 : {%d}" % (n, goCnt))
        return goCnt
re = gong(5)
print('최종적으로 반환 받은 공의 개수는 : {%d}' % re)

# 최종적인 공의 개수는 5번째 선수가 전달받은 최종값을 의미한다.


# 그럼 위 개념을 응용해서 한번 리스트의 합을 구하는 예제를 작성해보자


# 1. 리스트를 구현하고
# 2. 재귀함수를 생성 먼저 1~5까지 합을 구할건데
# 3. n==0 이 되면 가장 첫번째 값을 리턴 (기저조건)
# 4. 그럼 1번선수에서 0번선수를 호출한거니까
# 5. 1번선수의 값은 1번선수가 가지고 있는 리스트의 값 2+1 = 3을 sum(1) = 3리턴
# 6. 마찬가지로 1번을 호출한 2번선수한테서 1의값과 2번 선수가 가지고 있는 값을 합산해서 3번선수한테 인계
# 7. 끝까지 가서 마지막 선수한테 최종적으로 반환되서 올라온 반환값의 최종값을리턴


arr = [1,2,3,4,5]

def sum(n):
	if n == 0:
		return arr[n]

	else:
		result = arr[n] + sum(n-1)
		return result

a = sum(len(arr)-1)
print(a)


# 팩토리얼을 구현해보자

# 팩토리얼이란 n*(n-1)*(n-2) n의 수를 하나씩 줄여가면서 원하는 수의 개수만큼 곱해나가는 것이 팩토리얼이라고하고
# 팩토리얼의 특징은 0! = 1 이라는 것이다.
# 증명과정은 생략
# 때문에 기저조건으로 0이 들어온다면 return 1 을 보낸다면 n팩토리얼을 구할 수 있을거 같다.

def factorial(n):
	# 0! = 1 이기 때문에 1을 반환하도록 한다.
	# 그렇게 한다면 return 값으로 1을 반환시키고
	# factorial(1) 의 반환값이랑 현재 호출하고 있는 n의 값이랑 곱을해 또 다시 반환한다.
	if n == 0:
		return 1
	else:
		result = int(n) * int(factorial(n-1))
		return result


d = factorial(5)
print(d)



# 즉 재귀의 개념 자체는 무한한반복이라고 생각하면 되는데
# 그 무한한 반복속에서 기저조건으로 인해 탈출구가 있다고 생각하면 된다.
# 그 탈출구를 통해서 우리는 무한의 루프에서 빠져나올 수 있는 즉 반복문으로 가정해보자면 break 문 과 같다는 것이다.

# 재귀는 반환값을 받을 수 있는데 즉 호출한 곳에서 다음 호출한 상대에게 값을 리턴 받아야 할 경우가 생기는데
# 이럴경우 기저조건의 return 을 제외하고 기저조건 외의 return 값을 정의해줌으로써
# 해당 값을 리턴 받을 수 있다.
# 그렇게 된다면 다음 호출자의 값을 다시 전 호출자가 받는 것이고 그 값을 토대로 해당 값의 최종적인 형태를 또다시 그사람이 위로 올려준다면
# 생각해보면 축구의 패스와도 같다는것
# 물론 1-2, 2-3 에게 패스할 수 있다는 가정하의 패스라고 생각했을때

# 결국엔 받고 주고를 적절하게 섞을 수 있다면 재귀함수의 응용은 끝났다라고 본다.

# 이런 문제 같은 유형을 분할정복 이라고 하는데 이런걸 연습해봐야겠다
						

