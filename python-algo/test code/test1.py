# global_x = 0
# def function (a, b):
# 	# 함수의 인수는 순서가 있는 인수다. 따라서 위치인수
# 	# 함수의 인수도 지역변수임.
# 	# 리턴값은 지역변수 값을 리턴.
# 	# 인수를 받는 시점에서 변수가 생성이 되고, 변수가 생성되는 시점은
# 	# 함수 내부에서 생성 되기 때문에 지역변수라고 해야 맞음.
# 	a+= 1
# 	b+= 1
# 	return a, b


# a ,b = 1, 1
# def function ():
# # 이런 경우 전역 변수를 사용하게 됨
# # 함수 내부에서도 전역 변수가 사용이 될 수 있기 때문에
# # 인수로 넘기지 않는다면, 전역변수로 사용이 됨 = 전역변수의 참조.
# # 따라서 전역변수의 값을 변경하려면
# # global 값으로 정의한 다음 값을 변경
# # 정리하자면 함순 내에서 전역변수의 값을 변경하려면 global을 선언한뒤 
# # 값을 변경해야 됨
# a+= 1
# b+= 1
# return a, b

# # 이렇게 사용할때 키워드 인수를 사용
# # 이름을 명시해서 값을 전달함.
# # 이름 : value 값 형태로 전달.
# # 함수를 호출할때 사용하는 인수
# # 함수를 만들때 키워드 인수를 만드는게 아닌, 함수를 호출하게 될때, 변수의 이름에다가 값을 전달하는 방법을 키워드 인수 방식이라고 한다.
# function(a = 1, b=2)

# # 아래와 같은 변수들은 전역변수
# # function 함수에서 리턴하게 되는 것은 지역변수의 값을 리턴하게 됨
# # 
# a = function(1, 2)
# print(a)
# b, c = a
# print(b, c)

# print("area = ", b)



# # b,c 는 위치 인수 처럼 값을 전달 할 수 없고 반드시 키워드 인수로만 값을 전달할 수 있음.
# # 따라서 함수에 * 가 있다면, 키워드 인수로 전달되어야 하는 것과 구분.

# def func(a, * , b, c):

# func(10, b= 20, c=40)

# # * 인수 다음은 바로 키워드 인수로 전달받아야 하는데
# # b에 20을 키워드 인수 없이 넣으려는 시도가 있기 때문에 에러가 발생.
# func(10, 20, c=40)

# # 디폴트 인수 = 기본값을 가지도록 하는 인수
# # 이런식으로 되어 있다면,
# # day, message의 인수가 전달되지 않는다면 day, message는 기본값을 사용한다.
# def greeting(name, day="좋은날", message="안녕하세요?")


# # 철수만 인수로 보냈기 때문에 day,message는 default 값을 사용함
# greeting("철수")

# # 위치인수가 기본
# # 이때 기본 값을 가진 값들이 순서대로 들어간다는것.
# greeting("철수", "잘 지내시죠?")



# def greeting(name, day="좋은날", message):

# # aname에는 안녕 = message에 넣고 싶었지만
# # 위치인수에 의해서
# # "안녕" = day로 넘어가고 message는 값을 넘기지 않았으므로 에러가 발생.
# greeting("철수", "안녕")


# # 가변인수
# # 인수의 개수가 가변적인것 따라서 정해지지 않은것
	
# # 이를 가변인수라고 하고 변수의 개수가 달라질 수 있다.
# # tuple로 묶어서 보내진다라고 생각하면됨.
# def sum_many(*args):
# 	# 패킹된걸 unpacking 해서 사용할 수 있읜
# 	a,b,c,d = args
# 	print(a,b,c,d)
# print(sum_many(1,2,3,4))

# def printTotal(name, *scores):
# 	# name은 위치인수, *scores = 가변인수
# 	# 따라서 name은 반드시 인수로 전달이 받아 져야 하고, scores의 인수의 개수는 가변적으로 변할 수 있음
# 	total = 0
# 	for score in socres:
# 		total += score

# 	total = sum([score for score in scores if score > 50])
# 	print(total)


# # 가변인수 뒤에 디폴트인수가 있다면 1,2는 args, time = 3
# def sum_many2(*args, time=2):

# # 인수는 두개가 전달이 될테니까
# # 인수의 개수에서 - 디폴트 인수의 개수만큼이 가변인수로 들어간다.
# # 가변인수 뒤에다가 디폴트인수를 사용하는 것이 정석이다.
# # 가변인수 뒤에 기본인수.

# # 가변인수는 디폴트인수보다 앞에 나와야 한다.
# sum_many2(1,2,3)
# sum_many2(1,2,time=3)


# # 키워드 가변인수는 딕셔너리로 
# # 가변인수지만 키워드로 전달을 하는것이 키워드 가변인수.
# # 호출할때 전달하는 키워드 인수
# # 위치인수, *인수, 디폴트 인수 ,가변인수, 키워드 가변인수
# def sum_many3(x,y,**kwargs):

# 가변인수와 키워드 가변인수를 둘다 사용할 경우
# 가벼인수 다음에 키워드 가변인수를 사용해야함.
def sum_many4(*args):
	print(args)

# 이렇게 전달되면 예상치 못한 키워드 인수가 들어왔기 때문에 가변인수에 이런 형태로는 안됨
sum_many4(3, 5, one = 1)

	
# type annotation
# 타입 어노테이션 어떤 타입을 반환하는지 정의.
def total(n) -> int {
	
}

# 람다는 한 줄 짜리 축양형 함수
# 람다 인수 : 식
# 인터프리터기 때문에 람다 function을 한줄로 정의.
# 람다 다음에 식의 결과는 자동 return
# while, if 구문은 허락 되지 않음
g = lambda x,y  : x ** y
# 이름이 없는 람다 펑션을 만들어서 사용할 수 있음.
print((lambda x, y : x ** y)(2,3))

print(g(2,3))






















