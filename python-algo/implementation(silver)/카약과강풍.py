# 문제분석

# 카약을 빌려준다

# n-1, n, n+1
# n의 팀은 n-1 팀 n+1 팀에게 빌려줄 수 있따
# 만약 n-1, n+1 중 n에게 여분의 카약을 빌려받으면
# 빌려받은 n은 또 다시 다른 팀에게 빌려줄 수 없다


# 만약 여분의 카약을 가지고 온 팀의 카약이 손상되었다면
# 여분의 카약으로 재출전한다고 한다

# 그니까 n팀이 카약을 하나더 가지고 왔는데
# 만약 n팀의 카약이 부서졌다면 여분을 사용해서 출전한다는 얘기가된다


# add 카약을 하나더 가지고 온 팀이기 때문에
# n-1, n+1 값을 구하면
# 2, 4가 된다
# 이때 부서진 카약팀의 번호에 해당한다면 빌려주도록하는데
# 문제는 카약은 한개만 가지고 오기 때문에 부서진 팀 중 한팀에게만 빌려줄 수 있따

# 2 를 빌려주게 되면 4팀은 부서졌지만 탈락해야 되기 때문에

# 출전할 수 없게 된다

# 만약 3팀이 카약을 가지고 왔다고 한다면

# 1, 3, 5 팀이 하나씩 가지고 왔다고 한다

# 그럼 우선 각각 n-1, n+1 을 구한다면
# 2, 4
# 2 = 소생 
# 4 = 소생
# 3 = 2, 4
# 5 = 4, 6

# # 그럼 우선 첫번째 팀의 카약부터 빌려준다고 했을때
# 0번째 팀은 없기 때문에 현재 1의 카약은 하나더 있는 상황이고
# 두번째 팀이 부서졌기 때문에 1번 팀이 빌려줄 수 있이므로 1번팀의 카약을 사용해서 2번팀을 소생시킨다
# 그리고 3번 팀으로 카약을 빌려줄 팀을 변경하고
# 현재 3번이 카약을 줄 수 있는 팀이라면
# 그 팀을 살린다 4번은 n의 n+1 이므로 살릴 수 있다
# 때문에 4는 살리게 된다.

# 결과적으로 2, 4둘다 살았기 때문에
# 더 이상 살릴 팀이 없기에 5까지 가지 않고
# 종료하게 된다
# 그렇기에 모든 사람이 출전할 수 있다

# 뭔가 문제가 그리디 스러운데
# 출발하지 못하는 팀의 최솟값을 구하라고 하네

import sys
input = sys.stdin.readline

n, s, r = map(int, input().split())
# 팀번호는 중복되지 않는다
broke = list(map(int, input().split()))
add = list(map(int, input().split()))


# 부서진 팀을 hash 로 등록해놓자
# 2: 1, 4: 1 등록해두면 1이 감소 하게 된다면 해당 팀은 살게되는거지

# 5 2 3
# 2 4
# 1 3 5

# 1 2 3
# 1 2 3

# 자기 자신을 살릴수 있다면 자기 자신을 살리고
# 만약 자기 자신을 살리지 않지만 다른 팀을 살릴 수 있다고 했을때
# n-1 팀을 살린다
# n-1 or n
# 1->2
# 2->3
# 3->?

def check(num):
	n_1 = num-1
	n_p = num+1
	
	# 자기 자신이 있다면 자기 자신을 살리고
	if num in broke:
		check = [num]
		return check

	# 만약 둘 중에 하나라도 살릴 수 있다면
	# 우선 둘다 리턴한다
	if n_1 in broke or n_p in broke:
		check = [n_1, n_p]
		return check	


dic = {}
for i in broke:
	dic[i] = 1

# 최대한 살려주면되자나
for j in add:
	tmp = check(j)
	
	# tmp 애초에 줄 수 없는 팀도 생각해야됨
	if tmp == None:
		break

	if len(tmp) >= 1:
		for k in tmp:
			if k in dic:
				dic[k] -= 1
				del(dic[k])
				break
			else:
				continue
	
	else:
		pass

print(len(dic))

# 6 1 1 -> 카약을 하나더 가지고 온 팀
# 3 -> 부서진 카약팀
# 5 -> 카약을 가지고 온팀