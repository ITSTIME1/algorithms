# # 강산이네 반 아이들은 항상 20명이다

# # 20명이 있고 이게 아이들의 키다

# 1 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919
# 2 917 918 919 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 900
# # 뒤로 물러난 걸음수를 구하라는거니까
# # A학생이후로 모든 학생들이 하나씩 걸음을 이동하니까
# # 아 처음부터 모든 학생이 있는게 아니구나

# # 첫번째 케이스에서 0번인이유는
# # 앞에서부터 뽑아오면
# # 옮길 이유가 없기 때문이다
# # 결국 아무나 한명 뽑는다는건 첫번째부터 뽑아오라는 뜻이되네
# # 반증으로 맨뒤에서부터 뽑게된다면
# # 어떻게든 걸음을 옮기는 일이 생기기 때문에
# # 절대로 0이 나올 수 없다

# # 따라서 아무나 한명 뽑는 조건은 가장 앞에서부터 뽑는다.

# 3 901 902 903 904 905 906 907 908 909 910 911  912 913 914 915 916 917 918 919 900

# 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 900
# # 900이 들어왔을때는 앞에 자기보다 큰 사람이 한명이상 있으므로 그중 가장 앞으로 간다
# # 그럼 900을 제외하고 나머지 19명이 이동해야된다
# # 결국 이동하는 사람 제외하고
# # 나머지 리스트의 개수만큼 더해주면
# # 그게 걸음수의 총합이도니다.
# 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919


# 그럼 A학생부터 이후에 있는 아이들의 길이가 곧 걸음수의 총합이 되니까
# A의 위치부터 시작해서 한걸음씩 이네
import sys
from collections import deque

input = sys.stdin.readline

p = int(input())

cnt = 0
r = []
for i in range(p):
	h = list(map(int, input().strip().split()))[1:]
	h = deque(h)
	# 처음 가지고 온다 했을때면 리스트는 비워져 있을거고
	# 첫순서일것이다.
	if len(r) == 0 and i == 0:
		r.append(h.popleft())
	# 처음순서가 아니라면
	else:
		while len(h) != 0:
			first = h[0]
			index = 0
			flag = False
			for k in range(len(r)):
				if r[k] > first:
					index = k
					first = h.popleft()
					flag = True
					r.insert(index, first)
					cnt += len(r[index+1:])
					break
			# flag == True 라는건 큰 값이 존재한다는것
			if not flag:
				r.append(h.popleft())

	print(f"{i+1} {cnt}")
	r.clear()
	cnt = 0


