# 폴리오미노 와 비슷한 문제같네

# "동전의 개수가 최소가 되게한다."
# 나눗셈의 개념으로 접근해보자
# 최소 = 가장 작게
# 가장 작게 거슬러달라는 말이된다.
# 그렇다면 비교를 통해서 알아보자
# 20원 = 크기가 20이라고 가정해보자
# 2로 나눈다면 20개를 10조각으로 분해할 수 있다.
# 그렇다면 2원으로 20원을 얼마나 채울 수 있는가로 바꿔서 생각해보면
# 2원짜리 동전 10개 2+2+2+2+..+ 10개 있어야 한다는 걸 의미한다.

# 그럼 똑같은 방법으로 5로 나눠보자
# 그렇다면 5원이라는 동전인 4개가 20개를 채울 수 있게 된다.
# 그럼 차이만 보더라도 4개 > 10개 4개로주는게 더 작게 줄 수 있는 방법이 된다는 것이다.


# 그렇다면 우리는 이 사실로부터 큰 동전으로 먼저 n이라는 크기에 동전을 채워주어야 한다는 것으로 알 수 있고
# 이후 남은 동전도 사용하고 있다. 남은 동전을 버리지 않는다는 것
# 그렇다면 가장 크게 채워지고 남은 부분은 그 다음 큰 동전으로 계속해서 채워나가면
# 가장 작아질 수 있다는 사실을 알 수 있다.

# 이제 시간복잡도를 계산을좀 해보자면
# 거스름돈의 액수 = 크기는 곧 10만이 주어진다
# 그렇다면 우리는 나눗셈을 할 것이기 때문에
# 얼마나 많이 나눗셈 연산을 진행할지를 계산해본다면
# 최대 10만을 기준으로 생각했을때 10번 계산을 진행한다.
# 왜냐하면 1/5씩 줄어들다가 5로 나누지 못하는 순간 1/2씩 줄어들기 때문이다.

# 추가적으로 5로 나누어지지 않는다면 5로 빼준다.
# 13원이 예시다
# 그렇다는건 짧은 시간안에 도착할 수 있게 된다.
import sys

input = sys.stdin.readline

n = int(input())

# cnt = 0
# while n != 0:
# 	if n % 5 == 0:
# 		cnt += n // 5
# 		n = n-(5*(n//5))
# 	else:
# 		n -= 2
# 		cnt += 1
# 		if n < 0:
# 			print("-1")
# 			break

# print(cnt)
flag = True
while n != 0:
	if n % 5 == 0:
		cnt += n // 5
		n = n-(5*(n//5))
		break
	else:
		n -= 5
		cnt += 1
		if n < 0:
			print("-1")
			flag = False
			break
		if n % 2 == 0:
			cnt += n//2
			n = n - (2 * (n//2))

if flag:
	print(cnt)





