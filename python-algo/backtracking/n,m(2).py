# # 중복 없이 m개를 선택해야 되기 때문에
# # 1 1 같은건 중복되기 때문에 안되고
# # 1 2
# # 1 3
# # 1 4
# 2 1은 안되고 왜냐하면 1 2 가 있기 때문에
# 2 1 도 조합에서는 순서를 고려하기 때문에
# 사용할 수 없음

# 2 2 같은것이기 떄문에 사용할 수 없고
# 2 3 따라서 3부터 가능하다는 얘기가 됨 
 
 
# 이전 숫자가 이미 사용되었다면 다음 수에서 절대로 사용할 수 없음
# 왜냐하면 n개의 숫자들중 해당 숫자가 이미 봅힌것이기 때문에
# 순열 같은 경우 그걸 다시 집어 넣는다고 생각하면 다시 뽑힐 수 있지만
# 순서가 다르기 때문에 다른겨웅의 수로 본다.

# 하지만 조합에서는 1에서 2를 뽑든 
# 2에서 1을 뽑든 모두 같은 경우로 보기 때문에

# 해당 경우를 뽑아서는 안된다.

# 처음 시작을 1로 하니까
# 1로 m개를뽑을 수 있으때까지 뽑는다 단
# 중복이 되면 안되기 때문에 현재 뽑은건 True처리 함으로써 다시 뽑히지 않게 한다.
# 그럼 재귀를 돌릴떄 1은 이미 True로 되어 있기 땜누에 다음에서 선택되지 않는다.
# 그럼 2부터 시작하게 되는데
# 2는 선택되지 않았으니선택한다.
# 만약 그리고 당므 재귀를 돌린다.
# 이때 재귀를 기저조건에 의해서 확인해야하는데
# m개가 되었다느건 유망조건 즉 가능한경우의 수만 거쳐 왔다는 경우기 때문에 그 경우를 저장하거나 출력해준다.

# 그럼 그 재귀는 조욜가 되고
# 이전 재귀로 돌아가서 그 이전 재귀에서 더 돌릴 수 있는게 있나 확인해보낟
# 만약 3, 4 라면 4를뽑고 3으로 돌아오기 때문에
# 3 에서 도 돌릴 수 있는게 4가 있다.
# 그치만 1 2 3 4 를 뽑았을때 
# 더 이상 4까지 뽑았다면 다음에 그 어떤 수를 뽑으려고해도 3 2 1 4 라고 해도 같은 숫자기 떄문에 뽑을 수 없다.
# 따라서 1 2 3 4 딱 한개 의 경우만 나오게된다 m=  4인 경우

# 자 그러면 이걸 어떻게 구현해볼 수 이씅락

# m까지 도달하기 위해서
# 이전 재귀로 돌아와서 다음 재귀를 돌리기 위한 조건이 되는지 확인한다.
# 하만약 M = 2 라고 해봦
# 그럼 두개를 뽑고 나서 더 이상 뽑을 수 있는가 못뽑는다.
# 못뽑음과 동시에 그 수가 마지막 수여야 이전수로 돌아가서 더 이상 탐색하지 안흔ㄴ다.
# 즉 재귀 자체가 모든 경우가 되어야 한다.
# 따라서 ㅐㅈ귀 자체가 모든 경우가 되기 위해서
# 항상 그 해당 시작점으로 초기화를 해주고 for문을 돌게 된다면
# 항상 그 시작점 부터 시작하게 되니까
# 그 시작점이 뽑혀있으니 다음 시작점을 보내주고 그럼 다음 시작점부터 재귀가 돌게 되기 때문에 

# 1과 달랐던 점은 
# 항상 재귀를 돌릴때마다 앞에서부터 다시 탐색한다. 이는
# 앞에서부터 탐색할떄 1과 2같은 것들도 뽑히기 위해서다.
# 하지만 여기에서는 이미 뽑힌건 뽑지 않는다고 생각해야 되ㅣㄱ 때문에
# 앞서 1, 2 뽑혀있다면 그 건 절대로 뽑을 수 없다.
# 따라서 2까지 뽑았따면 3부터 뽑아야 한다는 소리가 되고
# 3부터 뽑으려면 3부터 for문을돌리게 만드러양하낟.
# 그러면 재귀가 종료되더라도 재귀가 돌아갔을때 해당 부분이 종료되면 더 이상 

# 1
# 2
# 3
# 이때 이전 경로로 돌아오고 나서 다음 4를 갈텐데 다시 왜냐하면 재귀에서 항상 자기보다 하나 큰것부터 넣었으니까
# 4

import sys
input = sys.stdin.readline


n, m = map(int, input().split())

number = [False] * (n+1) 
def recursive(start, s):

    if len(s) == m:
        print(s)
        return
    # 재귀를 돌리기 떄문에 기저조건이 무엇인지를 생각해본다
    # 이 문제에서 기저 조건이라고 하면 s의 길이가 될 것이다.
    # s의 길이라고 한다면 리스트로 만들어서 수열을 만들어준다.
    # 유망한것들로만 나열이 되어질 것이기 때문에
    # S는 항상 유망한 배열이 된다.
    for i in range(start, n+1):
        
        if not number[i]:
            print(i)
            number[i] = True
            s.append(i)
            recursive(i+1, s)
            s.pop()
            
            number[i] = False
    

# 항상 start+1부터 시작하니까
# 1부터 확인을안하지
# 1부터 확인했다면 visited[i] =False기 때문에
# s에 넣어질텐데
# 그걸 방지하기 ㅜ이해서 넣으거니까
# 와 이렇게 생각해야 되느구나 어렵네

백트래킹 
s = []
recursive(1, s)
