n, m = map(int, input().split())

visited = [False] * (n+1)

def recursvie(s, n, m):
    
    # 재귀의 조건을 s의 길이가 m이 되었을때
    # 그걸 출력해준다.
    if len(s) == m:
        print(" ".join(map(str, s)))
        return
    
    # 길이가 = m이 아니라는건
    # 아직 m까지의 수열을 만들지 못했다는 의미기 떄문에
    # m을 만들기 위한 수열의 수를 찾아야한다.
    # 이때 자기 자신은 안되며
    # 작은 것부터 시작해야 되기 떄문에
    for i in range(1, n+1):
        
        # 즉 방문하지 않았으면
        # 여기서 제한조건에 위배되지 않느지 판단하고 다음 단계로간다
        # 즉 방문했다라는건 유망하지 않으니까 재귀를 다시 돌리지 않고
        # 가지를 치지 않는다.
        # 결국 방문하지 않은 것만 가게 되는것이고
        # 방문하지 않은 곳만 가지를 뻗어나가게 된다.
        if not visited[i]:
            s.append(i)
            visited[i] = True
            recursvie(s, n, m)
            s.pop()
            visited[i] = False

# 아 이게 백트래킹이구나
# 그냥 재귀랑 비슷한거 같은데
# 이게 기본적인 백트래킹 이구나
# 그렇다는건 조건을 설정하는게 굉장히 중요하고
# 기저 조건에 도달했을 경우 어떻게 처리할지
# 이전 유망하지 않다고 판단하여 이전 단계로 돌아 왔을때 그 다음은 어떻게 선택할건지가
# 굉장히 중요한 과제가 되는거네
s = []
recursvie(s, n ,m)
            