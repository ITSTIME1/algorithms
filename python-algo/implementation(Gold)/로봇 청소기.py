# 로봇 청소기가 방을 청소하는거네
# 청소하는 영역의 개수를 구하는거고

# 좌표로 이루어져 있으며 r+1, c+1 로 봐야 된다는거
# 처음에 빈칸은 벽을 제외하고 빈칸은 전부 청소되지 않은 상태에서 시작하는거고


# 로봇청소기는
# 현재 칸이 가장 북, 남, 동, 서쪽 줄에는 하나 이상에 위치한 모든 칸에는 벽이 있다.
# 즉 모든 줄에 벽이 있다는거고 즉 그 방향에 줄에 벽이 하나 이상 있다는거자나

#  좌표 자체는 그대로 맵에 다가 적용하면 되고
#  1, 1이라면 좌표계에서 0, 1 세로로 0, 1 이다 . 즉 좌표계에서 실제 좌표인것
 

#  하나 이상에 위치한 모든 칸에는 벽이 있다.
#  가장 북, 동, 남, 서 줄 중에서 하나 이상에 위치한 모든 칸에는 = 하나 이상은 무조건 벽이 있다.stdin

#  로봇청소기가 있는 칸은 항상 빈 칸이다.
#  즉 로봇 청소기의 첫 좌표같은 경우는 반드시 빈 칸이다.
#  그럼 이건 빈 칸이라는거지 청소가 되지 않은 빈칸이거나, 청소가 된 빈칸 둘 중에 하나라는 거고

#  구하고자하는건 로봇청소기가 작동을 시작하고 부터 작동을 멈출때까지 청소하는 칸의 개수를 리턴하는것

# 1 번예제 처럼 북 동 남 서 의 줄에 하나 이상 즉 모든 칸에 벽이 있다고는 하지 않았으니까
# 하나 이상 하나 일 수 있고 하나보다 많을 수 있다는 것 반드시 벽으로 둘러 쌓여 있는건 아니라는 것이다.

# d = 0 북
# d = 1 동
# d = 2 남
# d = 3 서

# 바라보고 있는 방향인거고

# 오케이 그러면
# 우선 로봇청소기가 어디에서 시작하는지를 좀 알아야지
# 로봇청소기가 멈출때 까지 while문을 돌릴거고
# 처음 좌표의 위치는 항상 빈칸이니까
# 아 처음 빈칸은 전부 청소가 되어지지 않았다 라는 조건이 있으니까
# 청소가 되어지지 않은 상태에서 항상 시작하는걸로 생각하면 된다.
# 그렇다면 좌표가 청소되어지지 않은 상태라면 현재칸을 청소하기 위해서 다른 문자로 표시한다. "x"
# 그럼 이제 x는 청소를 했다는 거고 그 칸을 청소했다면 나머지 4방향을 현재 좌표를 기준으로 검사한다.
# 만약에 4방향을 전부 검사했는데 청소가 모두 되어 있다면 = 청소가 되어지지 않은 빈칸이 없는 경우
# 바라보는 방향을 유지한 채로 한칸 후진할 수 있다면 이건 곧 "빈 칸" 이라는 거고 한칸 후진 한칸 뒤로 간다는건데 그럼 방향에 따라서 후진의 방향성이 달라질거고
# 1번으로 돌아간다 후진할 수 있다면
# 만약에 후진이 불가능하다면 이때 작동을 멈춘다.

# 만약에 그럼 4방향을 검사할때 하나라도 청소되지 않은 빈칸이 존재할 경우
# 현재 위치에서 반시계방향으로 회전한다. 그렇다면 반시계 방향으로 회전하니까 북->서->남->동 
# 회전을 했다면 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 즉 0 인경우 해당 방향으로 한 칸 전진한다.
# 그 다음 1번으로 돌아간다.
# 시뮬레이션 유형이네
# 어떤 방향인지는 d의 방향성으로 따져보고

# 우선 방향으로 전진하냐 후진하냐가 방향에 따라서 전부 값이 다르기 때문에 방향성을 하나만 가지고 있으면 안되고 두개를 가지고 있어야한다.
# 딕셔너리로 관리하는게 편할거 같다. [(), ()\]
# 이걸 딕셔너리로 관리해서 북 서 남 동 순으로 관리하는게 편할거같다 그래서 북 : [(), ()] 첫번째는 전진, 뒤에는 후진
# 선택하면 될거 같고
# 좌표를 갱신해주는건 후진할 수 있는 경우와, 전진할 수 있는 경우이며
# 후진할 수 있는 경우는 모든 빈칸이고 벽이 아니라 전부 후진할 수 있고, 전진 같은 경우는 앞쪽 칸을 봤을때 청소가 되지 않은 빈칸일 경우만 전진 할 수 있다.
# 그대로 구현하면 될거 같은데

# 근데 가장 자리 쪽에 빈칸이 있을때는 4칸을 비교할때 범위가 넘어가는 곳이 분명 존재한다.
# 가장 자리기 떄문에 그럼 4방향을 검사할때 맵의 범위를 넘어가는 곳은 예외처리를 해주어야 할것 같고
# 그냥 가장자리는 모든 칸에 벽이 있다고 봐야 될거 같다 왜냐하면 하나 이상에 위치한다라는건 한칸 이상에 위치할 수 있는 걸 말하며
# 그렇게 위치할 수 있는 모든 칸에는 벽이 있다고 했으니 주위가 모드 벽이라는게 증명된다.



import sys 
input = sys.stdin.readline

# 방의 크기를 입력받는다.
n, m = map(int, input().split())
# 좌표, 방향이 입력된다.
r, c, d = map(int, input().split())

# 탐색할 맵을 입력 받는다.
board = [input().split() for _ in range(n)]

# 북, 서, 남, 동 순으로 전진과 후진을 컨트롤할 맵을 만들어주자
# d = 0 북
# d = 1 동
# d = 2 남
# d = 3 서
control = {0: [(-1, 0), (1, 0)], 3: [(0, -1), (0, 1)], 2: [(1, 0), (-1, 0)], 1: [(0, 1), (0, -1)]} 

# 로봇이 작동을 중지할때까지 계속 반복을 할거고
cnt = 0
# 북 동 남 서
dx = [0, 1, 2, 3]


while True:
	# 현재칸이 청소되지 않은 경우, 현재칸을 청소한다.
	if board[r][c] != "X":
		board[r][c] = "X"
		cnt += 1
		# 현재칸의 주변 4칸중 청소되지 않은 빈칸이 없는지 확인한다.
		# 4칸 모두 검사하는데
		# 만약 전부 청소가 되어 있다면 바라보는 방향을 유지한채로
		# 한 칸 후진할 수 있다면 후진한다.
		# 청소되지 않은 빈칸이 없는 경우
		# 청소되지 않은 빈칸이라는건 빈칸중에 X가 전부 있다는것 그럼 전부 청소가 되어졍 ㅣㅆ는거
		if board[r-1][c] != "0" and board[r][c-1] != "0" and board[r+1][c] != "0" and board[r][c+1] != "0":
			# 바라보는 방향을 기준으 한칸 후진할 수 있다면
			if board[r+control[d][1][0]][c+control[d][1][1]] == "X" or board[r+control[d][1][0]][c+control[d][1][1]] == '0': 
				r, c = r+control[d][1][0], c+control[d][1][1]
				continue
			elif board[r+control[d][1][0]][c+control[d][1][1]] == '1':
				break

		# 청소되지 않은 빈칸이 있는 경우
		elif board[r-1][c] == "0" or board[r][c-1] == "0" or board[r+1][c] == "0" or board[r][c+1] == "0":
			# 모두가 청소가 되어져 있지 않은 경우 즉 빈칸이 존재하는 경우. (하나라도)
			# 현재 방향의 인덱스를 가지고 와서 반시계 방향으로 회전해야하니까
			# 인덱스를 감소시킨다. 그리고 그 위치를 잡아주
			d = dx[dx.index(d)-1 % len(dx)]
			# 방향을 바꾼뒤 현재 방향을 기준으로 
			# 앞쪽 칸이라고 하면 전진하는 칸을 의미한다.
			# 전진은 청소되지 않은 빈칸 0이라면 좌표를 갱신해준다.
			if board[r+control[d][0][0]][c+control[d][0][1]] == '0':
				r, c = r+control[d][0][0], c+control[d][0][1]
	# 돌아갔는데 현재 칸이 청소가 되어 있다면
	else:
		# 2번으로 돌아가야지
		# 현재 칸의 주변 4칸중 청소되지 않은 빈칸이 있나 없나를 보는거야
		if board[r-1][c] != "0" and board[r][c-1] != "0" and board[r+1][c] != "0" and board[r][c+1] != "0":
			# 바라보는 방향을 기준으 한칸 후진할 수 있다면
			if board[r+control[d][1][0]][c+control[d][1][1]] == "X" or board[r+control[d][1][0]][c+control[d][1][1]] == '0': 
				r, c = r+control[d][1][0], c+control[d][1][1]
				continue

			elif board[r+control[d][1][0]][c+control[d][1][1]] == '1':
				break

		# 청소되지 않은 빈칸이 있는 경우
		elif board[r-1][c] == "0" or board[r][c-1] == "0" or board[r+1][c] == "0" or board[r][c+1] == "0":
			# 모두가 청소가 되어져 있지 않은 경우 즉 빈칸이 존재하는 경우. (하나라도)
			# 현재 방향의 인덱스를 가지고 와서 반시계 방향으로 회전해야하니까
			# 인덱스를 감소시킨다. 그리고 그 위치를 잡아주
			d = dx[dx.index(d)-1 % len(dx)]
			# 방향을 바꾼뒤 현재 방향을 기준으로 
			# 앞쪽 칸이라고 하면 전진하는 칸을 의미한다.
			# 전진은 청소되지 않은 빈칸 0이라면 좌표를 갱신해준다.
			if board[r+control[d][0][0]][c+control[d][0][1]] == '0':
				r, c = r+control[d][0][0], c+control[d][0][1]

print(cnt)

# 왜 113이지
# [['1', '1', '1', '1', '1', '1', '1', '1', '1', '1'],
#  ['1', '0', '0', '0', '0', '0', '0', '0', '0', '1'],
#  ['1', '0', '0', '0', '1', '1', '1', '1', '0', '1'],
#  ['1', '0', '0', '1', '1', '0', '0', '0', '0', '1'], 
#  ['1', '0', '1', '1', '0', '0', '0', '0', '0', '1'], 
#  ['1', '0', '0', 'X', 'X', '0', '0', '0', '0', '1'], 
#  ['1', '0', 'X', 'X', 'X', 'X', '0', '1', '0', '1'], 
#  ['1', 'X', 'X', 'X', 'X', 'X', '1', '1', '0', '1'], 
#  ['1', 'X', 'X', 'X', 'X', 'X', '1', '1', '0', '1'], 
#  ['1', '0', 'X', 'X', 'X', 'X', '0', '0', '0', '1'], 
#  ['1', '1', '1', '1', '1', '1', '1', '1', '1', '1']]