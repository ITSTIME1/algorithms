import sys
import heapq
from collections import deque
from itertools import permutations, combinations, product, combinations_with_replacement
input = sys.stdin.readline


# 괄호를 적절히 쳐서 식의 값을 최소로 만들고 싶어한다.


# 0~9
# +, -

# 마지막 문자는 숫자
# 연속해서 두개 이상의 연산자가 나타나지않아.
# 최대 5자리

# 수는 0으로 시작될 수 있다.

# (55-50)+40 = 45
# 55-(50+40) = -35

# (10+20)+(30+40) = 100
# 이건 어떻게 묶든간에 똑같은 답이 나온다.

# 00009-00009 = 9-9 = 0


# +가 있다면 앞에서부터 +부터 계산
# 플러스를 기준으로 양옆의 식을 계산.
# 그리고 왼쪽 숫자의 앞에 -가 있다면-를 붙여서계산

# 항상 플러스부터 계산후 -를 계산한다면 결과가 나올거 같은데
# 그렇게 되면 2번 예제같은 경우 +부터 앞에서부터 차례로 계산하니 100이란 답이 도출이되고

# # 큰수에서 - 작은 수를 빼면 값이 최소가 되니
# # 가장 큰 수부터 만드는게 관건일거같은데
# (55-50)+40-30 = 5

# 55-(50+40)-30 = - 65
# -120 + 55 = -65

# 이렇게 덧셈만 먼저 계산해준다면 -는 어떤 방향의 값을 계산하더라도 동일값이나온다

# -80-90+55 = -115
# -90-80+55 = -115
# re = 55-(50+40)-(30+50)


# 그럼 플러스 연산자를 기준으로
# 플러스 인덱스를 찾아서 양옆의 값들을 더해주고
# 아니면 숫자가 들어온다면 리스트의 숫자를 계속해서 붙여주고
# 연산자가 나온다면 연산자만 따로 저장
n = input().split("-")
total = []
for i in n:
	ar = 0
	# + 붙어 있는 것들은 +로 분리해주고
	# 계산을 해주어야하니까
	# 분리한 것들을 가지고 와서 연산을 수행해준뒤
	# 그 합계를 total 에 넣어주기만 하면됨
	# 그랬을때
	# +가 없는 수 하나의 단위는
	# +로 나뉠게 없기 때문에 그냥 숫자만 남게 되어 숫자만 처리가된다.
	s = i.split("+")
	for j in s:
		ar += int(j)
	total.append(ar)
	
cnt = 0
for i in range(len(total)):
	if i == 0:
		cnt += total[i]
	else:
		cnt -= total[i]


print(cnt)

# 50-(55+30+20)-50
# 50-115-50 =
# -115+50-50

# 괄호를 어떻게 채우지..

# 아이디어는 맞았는데 구현이..

# 이 문제에서 배울점은 split() 을 통해서 +, - 로 나뉘면
# 그 기호 문자를 중심으로 나뉘어 진다는 기본적인걸 다시 알게 되었고
# 연산의 이해를 해본다면 첫문자를 제외한 나머지 문자들은 계산식이 어떻게 더해지든 똑같았다

# 거기서 추리해내야 했던건 +로 되어 있던 값들을 계산해준뒤는 - 값으로 나누었기 때문에
# 그 값들은 전부다 -라는것이다
# 때문에 첫값을 제외한 나머지 값들을 빼준다면 가장 첫문자는 무조건 숫자기때문
# 분석을 더 철저하게 해야겠다 그리디는..
