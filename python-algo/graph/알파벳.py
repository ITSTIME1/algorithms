# bfs 풀이
# bfs
# 아 이런 풀이구나 신박하네
# 이야..
# 이렇게 하면 모든 경우를 탐색할 수 있으니까
# 그럼 마지막까지도 중복되지 않은 부분만 남게될테니까
# 이게 되네 신기하네
# 중복을 제거한다는게
# 만약 같은 문자열이 존재한다면 없애니까


# dic을 이용해서 이미 방문한 지점을 1로 표현하게 되면
# 다른 루트로 지나갔을때는 새로운 알파벳은 지금까지 지나온 모든 칸ㅌ에 적혀있는
# 알파벳과는 달라야하므로
# 하나의 지점부터 시작하지만
# 다른 루트로 지나가기 때문에
# 그렇게 지나간 다른 루트들은 모두 독립적인것.
# 즉 하나의 루트를 통해서 방문한 것들은
# 그 루트를 통해서 지나온 알파벳들만 신경을 써야 한다는것.
# 만약 이렇게 신경을 쓰지 않는다면
# 결국 최소 이동거리가 되버림
# 최소이동거리가 된다는것은
# 최대한 많이 이동할 수 있는게 아닌
# 미리 모든 알파벳들을 탐색하면서
# 루트를 아예 차단해버리게 됨
# 루트를 아예 차단해 버리게 된다는것은
# 각기 다른 알파벳만을 신경써야 하지만
# 모든 루트에 대해서 모든 알파벳을 공유하고 있기 때문에
# 빨리 끝나게됨
# 따라서 독립적으로 알파벳을 신경써야 한다는게 중요함

# 또한 메모리 측면을 좀 고려해본다면
# 하나의 루트라도 같은 알파벳을 거친 루트가 존재할 수 있기 때문에
# 마지막에 도착한 루트는 그 4방향을 탐색한다고 하더라도
# 같은 문자열을 가지고 있기 때문에
# 4방향의 문자가 같은 의미를 갖게 된다.
# 따라서 그건 같은 중복의 의미를 갖는것
# 그런 경우는 미리 제거해서 1/2 로 만든다는것.
# ㅇㅋㅇㅋ

# 따라서 이 문제는 중복을 제거함으로써 메모리를 효율적으로 사용하는방법
# 알파벳을 루트마다 독립적으로 고려해야 하는것.
# 이 두문제를 해결로 잡아야한다.
# 그러기 위해서 set자료구조를 사용하면 중복을 제거하면서
# 각기 다른 독립적인 알파벳을 고려할 수 있으니까 아하..

import sys
from collections import deque
from string import ascii_uppercase

r, c = map(int, input().split())

board = [list(input()) for _ in range(r)]


def bfs(sx, sy):
	queue = deque([(sx, sy)])
	dx = [(-1, 0), (1, 0), (0, -1), (0, 1)]
	dic = {alpha : 0 for alpha in ascii_uppercase}
	dic[board[sx][sy]] = 1
	cnt = 1
	while queue:
		x, y = queue.popleft()
		for index in range(4):
			nx = dx[index][0] + x
			ny = dx[index][1] + y

			if 0<= nx < r and 0 <= ny < c:
				if dic[board[nx][ny]] == 0:
					dic[board[nx][ny]] = 1
					queue.append((nx, ny))
					cnt += 1

	print(cnt)

bfs(0, 0)