# n by n 크기의 보드에서 상어는 이동한다.
# 아기 상어와 물고기는 각자 크기를 가지고 있다.
# 초기 아기 상어의 크기는 2이고
# 물고기의 크기는 1~6사이다.
# 아기 상어는 상하좌우 인접한 칸만 이동할 수 있고
# 아기 상어는 다음 칸으로 이동 할때 자신보다 크기가 큰 물고기가 있다면
# 그 칸은 지나가지 못한다.
# 따라서 작거나 같은 칸은 모두 지나갈 수 있다는 뜻이되며
# 범위 안에 있고 자기보다 크기가 작거나 같으면 지나간다.
# 아기 상어는 또한 물고기를 먹게 되는데 자기보다 크기가 작은 물고기만 먹는다.
# 따라서 크기가 큰 물고기는 먹을 수 없고, 자기랑 크기가 같은 물고기도 먹을 수 없다.
# why ? 자기보다 크기가 작은 물고기만 먹을 수 있기 때문이다.


# 이제 상어가 상하좌우로 인접한 칸을 이동할때 조건이 존재한다.
# 더 이상 먹을 수 있는 물고기가 공간에 없다면 == 자기보다 크기가 큰 물고기만 남았다거나
# 혹은 물고기가 없다거나 이러한 경우는 엄마 상어에게 도움을 요청하는게 되기 때문에
# 종료한다.
# 문제에서 구하고자 하는건 엄마에게 도움을 요청하지 않고 상어 스스로 물고기들을 먹게 되는 시간이니까
# 또한 현재 상어가 먹을 수 있는 물고기들이 1마리라면 그 물고기를 먹는다.
# 만약 현재 상어가 먹을 수 있는 물고기감ㄴ 1마리 이상이라면 즉 여러 마리라면 거리가 가장 가까운 물고기를 먹는다.
# 거리가 가장 가까운 물고기라는건 그 물고기를 먹기 위해서 지나야 하는 최소를 의미한다.
# 따라서 현재 상어의 크기에서 먹을 수 있는 물고기들의 위치들 중 최소를 말한다.
# 그럼 이러한 물고기가 한마리라면 먹을 수 있는 물고기이면서 한마리 밖에 없다면 2번 조건에서 먹을 수 있는 물고기가 한마리라면 그 물고기를 먹는다.
# 만약 여러 마리라면 그러한 최소값을 가지는 물고기들을 찾았을때 여러마리라면
# 가장 위에 있는 물고기 = x가 가장 작은거 그러한 물고기도 여러마리라면 가장 왼쪽에 있는 물고기 가장 y좌표가 작은걸 먹는다.
# 현재 상어 크기보다 작은 물고기를 먹게 되면 그 칸은 빈칸이되고
# 이때 고려해야 되는 점은 먹을때마다 크기가 증가하며, 이동 거리가 변한다.
# 즉 위 조건들을 만족했을때 물고기를 먹으러 가게 되는데 그 물고기를 이동과 동시에 먹게 되면
# 그때의 아기 상어 크기와 먹은 물고기 횟수가 같게 된다면 크기가 변경 되기 때문에 먹을 수 있는 물고기도 바뀌게 된다.
# 또한 이전 위치를 기준으로 먹을 수 있는 물고기들을 봤을때 가장 가까운 물고기들이 있는 위치는 달라지기 때문에
# 현재 먹은 위치에서의 위치도 달라지게 된다.
# 따라서 현재 위치에서 먹을 수 있는 물고기의 위치가 또 달라지게 된다는게 된다.
# 그렇기 때문에 이동할때마다 이동거리가 변하면 새로 다시 찾아야 하기 때문에
# bfs를 이동할때마다 즉 물고기를 먹고 나서 계속 찾아야 한다는게 된다.
# 먹고 난 이후 다시 bfs를 수행해서 먹을 수 있는 물고기를 찾게 된다면
# 먹고 난 이후 크기가 변경된 시점에서 다시 물고기를 찾게 되므로 위에서 언급했던 문제가 사라지고
# 이동거리가 변경 된다는 점에서도 다시 bfs를 수행해서 먹을 수 있는 물고기들과의 위치를 찾기 때문에
# 만약 크기가 변경되는 시점이라면 크기가 변경된 물고기 까지 포함해서 bfs를 통해 먹을 수 있는 물고기를 다시 찾음과 동시에 이동거리도 변경된 시점에서
# 다시 찾을 수 있게 된다.
# 그렇다면 bfs를 수행하고 먹을 수 있는 물고기가 정해졌을때 그 물 고기를 먹은다음
# 그 물고기에 있는 칸은 0으로 변경되며, 이후 현재 상어 위치가 변경 되었기 때문에
# 현재 상어의 위치또한 0으로 변경된다. 그리고 상어 이동은 1초가 걸리기 때문에
# 먹을 수 있는 물고기한테 가는 동안 1초씩 걸리게 되며
# 그렇게 먹을 수 있는 물고기 한테 가는 시간들의 합이 곧 상어가 이동한 시간이 된다.
# 따라서 상어가 이동한 거리를 관리해야 된다는 걸 알 수 있고
# 상어가 이동한 거리를 전부 더해서 시간을 출력할 수 있을것 같다.
# 또한 그렇게 먹은 물고기의 개수가 현재 상어의 크기와 같다면 현재 상어의 크기를 1올린다.

# 오케이 이러한 점들을 유념해서 한번 코드를 짜보자 .
import sys
from collections import deque
input = sys.stdin.readline


n = int(input())

arr = [list(map(int, input().split())) for _ in range(n)]


# 처음 상어 위치를 알아야 bfs를 상어 위치부터 수행할 수 있기 때문에 9의 위치를 찾는다.
dx = [(-1, 0), (1, 0), (0, -1), (0, 1)]
sX, sY = 0, 0
for i in range(n):
	for j in range(n):
		if arr[i][j] == 9:
			sX,sY = i, j
			break


def bfs(s, e, arr, shark, dx):	

	# 이미 방문한 지점은 다시 가지 않는다.
	# 최소한의 지점을 찾아야 하기 때문에 그리고 거리를 갱신할 테이블을 만들어준다.
	queue = deque([[s, e]])
	visited = [[0] * n for _ in range(n)]
	distance = [[0] * n for _ in range(n)]

	# 처음 상어의 위치를 방문을 시켜주고 이후 현재 상어의 위치는 재방문하지 않는다.
	# 거리를 1로 둬서 그렇구나
	visited[s][e], distance[s][e] = 1, 1


	# 큐에 담기는 값은 방문할 수 있는 지점이 될거고
	fish = []
	while queue:
		x, y = queue.popleft()

		for idx in range(4):
			nx = dx[idx][0] + x
			ny = dx[idx][1] + y

			# 우선 적으로 범위 내에 존재하고 아직 방문하지 않은 지점이라면
			if 0<= nx < n and 0<= ny < n and visited[nx][ny] == 0:
				# 방문을 하게 되는데 이때 방문의 조건은
				# 자기보다 큰 물고가 있는 칸으로는 갈 수 없다.
				if arr[nx][ny] > shark: 
					continue
				else:
					# 크다의 반대가 작거나 같기 때문에
					# 이런 경우만 방문이 가능하다.
					# 따라서 방문을 했다고 알려준뒤, 거리를 현재까지 얼마나 왔는지를 갱신한다.
					# 따라서 이전 거리에서 + 1을 해주어 현재까지 얼마나 많은 칸을 걸어 왔는지를 알려준다.
					queue.append([nx, ny])
					visited[nx][ny] = 1
					distance[nx][ny] = distance[x][y] + 1
					# 그런다음 자기랑 같은 크기의 물고기가 존재한다면 먹지는 못하지만 이동은 가능했고
					# 자기보다 작은 물고기는 먹을 수 있기 때문에 한번더 분기를 해서 먹을 수 있는 물고기들을 걸러낸다.
					# 이후 그 물고기들 중에서 필터링을 거쳐야 하기 때문이다.
					# 하지만 0도 shark보다 작기 때문에 0보다는 커야한다.
					# 0은 빈칸이기 때문에 물고기가 아니다.
					# 먹을 수 있는 물고기들을 비교하기 위해서 fish테이블에 넣어줄건데
					# 이때 거리가 가장 최소인걸 우선으로 비교하기 때무넹
					# 거리, x, y
					# 거리가 같은게 여러개라면 x를 기준으로 x가 같은게 여러개라면 y를 기준으로 정렬을 수행해야 되기 때문이다.
					if 0 < arr[nx][ny] < shark:	
						fish.append([distance[nx][ny]-1, nx, ny])

	# 이제 모든 방문이 가능한 피쉬들 중에서 먹을 수 있는 피쉬들이 걸러졌다.
	# 그럼 이제 이러한 피쉬들중 가장 작은걸 찾아야하며
	# 그러한 피쉬들중 가장 작은게 여러개라면 x, y순서로 정렬해본다.
	# 그렇게 해서 가장 작은 값이 앞에 있으니까
	# 앞에 있는 것만 보낸다.
	
	# 거리를 좀 바꿔야 할거 같은데
	if fish:
		fish.sort(key = lambda x : (-x[0], -x[1], -x[2]))
		
	return fish
	
	

# 시간복잡도를 좀 계산해보면
# bfs의 시간복잡도는 O(V+E)
# 정점의 개수에 +E 간선의 개수가 된다.
# 정점은 간선은 4개 상하좌우 
# 정점은 방문할 정점의 개수가 4개니까
# 그럼 정점의 개수가 n개니까 n^2만큼 따라서 n의 최대치가 20이니까
# 20 * 20 = 400
# 또한 각 정점의 연결된 간선이 4개씩이니까
# O(4NM)
# 왜냐하면 nm개씩 방문할때마다 4개의 간선을 검사하니까
# 따라서 한 정점당 4개씩 간선을 타고 진행하게 되니까
# 한정점당 4개씩 방문 * nm개의 정점이 존재
# 4nm
# 따라서 4를 앞으로 빼서 표현하게 되면
# 따라서 nm = 400이고 거기에 4개의 간선이 추가 되면 1600
# 또한 샤크의 위치를 차즌ㄴ데 n^2만큼의 시간소요가 걸리기 때문에
# 400 만큼 그러면 bfs를 한번 실행하는데 1600 + 400 만큼의 시간이 걸리니 총 2000만큼의 시간이 걸린다.
# 또한 bfs는 한번 실행하는게 아니라 먹을 수 있는 위치에 샤크가 가서 또 모든 정점을 탐색하기 때문에
# 여기에다가 20 * 20 만큼의 시간이 더 들게 되고 그러면 400 만큼 추가적으로 더 들게되니

# 400만큼의 시간이 bfs를 실행할때마다 드니까
# ((400) * 4) * 400) + 400 = 이전에 (bfs를 실행하고) *  + 샤크의 정점을 찾는 시간에
# 따라서 O(4nm * 4 * 400) + 400 
# 2000 * 400 = 800000 + 400
# 약 80만400정도
# c언어 기준 1초에 1억번 연산을 진행하니 그보다 상대적으로 늘니 python은 약간의 3배정도의 시간여유를 더 주게 된다면
# 충분히 돌 수 있겠다.
# 1: 1000000000 
# 1초에 1억번
# 1초에 3천만번 정도
# 초당 3천만번이면
# 80만이니까
# 그럼 약 80 / 3천만번 = 0.02초 
# 1: 30000000 = x : 800000
# 30000000x = 800000
# x = 0.02초정도 + 추가저인 정렬알고리즘이 매 bfs마다 실행되기 때문에 o(nlogn)
# 20이니까
# 20 * 4 = 80 한번 수행하는데 약 80정도
# 그럼 저기에다가 80을 곱해보면
# (2000 * 400 * 80) + 400 = 800000 * 80 = 64000000만 6400만 에다가 + 400이니까
# 64000400
# 1: 30000000 = x : 64000400
# 30000000x = 64000400
# 대략 2.13초 정도
# 대략 2초정도를 감안에서 나올 수 있을 거 같은데
# Onlogn때문에


# 상어 위치에서 bfs를 수행해야 하지만 먹을 수 있는 물고기한테 갈때마다 bfs를 다시 수행해야 되기 때문에
# while문으로 엮어서 먹을 수 있는 물고기가 공간상에 없을때만 종료되게 한다.
eat, shark, total = 0, 2, 0
while True:
	result = bfs(sX,sY, arr, shark, dx)

	# 먹을 수 있는 물고기가 정해지지 못했을때
	# 따라서 먹을 수 있는 물고기가 정해지지 못했다는건 먹을 수 있는 물고기가 없을때만.
	if not result: break

	# 그렇지 않다면 먹을 수 있는 물고기가 있기 때문에 그 중 하나를 선택해서 와야 하므로
	# 위 조건에서 만족하는 결과중 가장 최적의 하나를 선택한다.
	# 따라서 먹을 수 있는 위치들이 좌표와, 거리로 주어지게 된다면 
	# 거리가 가장 작은 값을 기준으로 먼저 정렬이 되고 작은 값으로 정렬했을때
	# 이들의 개수가 여러개라면 x가 가장 작은걸로 정렬하고, x가 가장 작은걸로 정렬했을때도 여러개가 있다면 y를 정렬해주고
	# 그랬을때 가장 적합한 녀석이 가장 왼쪽에 있는 녀석이 될거기 때문에
	# 왜냐하면 거리가 가장 작은 값을 먼저 기준으로 정렬했으니 최소값은 먼저 거리가 가장 작은걸 기준으로 삼는다.
	# 따라서 거리가 가장작은 값이 오름차순으로 정렬되어 있기 때문에 가장 앞에 위치해 있다.
	# 모든 조건을 만족하더라도 첫번째는 distance, 두번째는 x, 세번째는 y순으로 정렬되기 때문에
	# 우선적으로 distance가 낮은 값으로 먼저 정렬이 된다.
	# 이후에 distacne값이 같으면 x로 정렬이 되기 때문에 항상 distacne가 작은 값이 가장 앞에 있다.
	distance, fx, fy = result.pop()
		
	# 물고기를 먹어주는 것이기 때문에 물고기를 먹은 자리는 0으로 바꿔준다.
	# 또한 이전의 상어 위치를 바꿔준다.
	# 이후 bfs에서 그 공간은 상어가 없는 위치기 때문에
	# 빈칸으로 남겨둔다. 크기를 갖게 되면 값이 달라지니까
	# 애초에 크기를 가질 수도 없다. 물고기가 아니기 때문에
	arr[sX][sY], arr[fx][fy] = 0, 0

	# 물고기를 먹음과 동시에 eat를 증가시켜주고
	# 그럼 현재 먹은 물고기 수가 shark의 크기와 같다면 shark의 크기를 1증가 시켜준다.
	# 먹은걸 초기화 해준다. 그 크기를 위해서 먹은 것이기 때문에
	# 샤크의 크기가 달라졌으니 샤크의 크기 만큼 다시 먹어주어야 한다.
	eat += 1
	if eat == shark:
		shark += 1
		eat = 0

	# 물고기를 먹었으니 현재 위치를 물고기를 먹은 위치로 바꿔주어야 하니까
	sX, sY = fx, fy
	# 그리고 거기까지 이동한 거리가 곧 상어가 이동한 시간이 되기 때문에
	# 왜냐하면 상어는 1초마다 이동하니까
	# 1초마다 이동해서 물고기가 먹을 수 있는 곳까지 갔으니까
	# 따라서 total에 현재까지 이동한 시간을 모두 더해준다.
	total += distance

print(total)




