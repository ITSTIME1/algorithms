# 우선 별찍기 - 10번 문제를 풀려면 재귀함수에 대해서 알아보자

# 재귀(recursion) 자기 자신을 반복적으로 호출하는 걸 말한다.
# 어떠한 특정한 조건을 명시해주지 않는다면 무한적으로 호출하기 때문에

# 무한적으로 호출하는걸 막기 위해 특정 조건을 걸어준다.

# 예를들어 합을 구하는 함수를 구한다고 해보자


# 먼저 n을 입력받는다 만약 5를 입력했다고 가정해보자

# 그럼 sum함수에n을 파라미터로 받고있으니 n의 값은 현재 5>0 큰 상태이다.

# 그럼 합계를구해야하기 때문에
# 5+4+3+2+1
# 의 순서대로 구할 수 있을것이다.
# 그럼 이렇게 생각해보자
# 5를 입력했으니 0보다 작거나 같다면 합계를 더해서 올려주는거다

# 즉 5를 호출한다면 0보다 크기 때문에 5+(5-1)의 형태로 반복호출하게끔 만들어준다는 것이다.
# 이렇게 한다면
# sudm(4)값이 파라미터로 들어가게 되고
# 4 > 0보다 크기 때문에
# 4+(4-1) 형태로 호출되게 된다.
# 이런형태로 반복적으로 호출하게 된다면
# n이 0인순간이오는데
# 0인순간에서 n을 그대로 리턴해준다면
# 마지막인 1+0 에서 0값이 리턴되어 1이 될것이고
# 그럼 sum(1) 의 값인 1+0을 리턴하게 되어 = 1을 리턴하게 된다
# 그럼 이전의 호출했던 sum(2)는 2+1이기 때문에 1의 값인 1을 더해 총 3을 리턴하고
# 이전 호출했던 sum(3)에서는 3+2를 호출했기 때문에 3+3 이 되어 6을 리턴하게 된다.
# 위의 규칙에서 보았듯이
# 이전 호출되었던 값들이 다시금 위로 올라가면서 값을 던져주는형태이다.

# 그림으로 상상해본다면
# 축구선수 5명이 있다고 가정해보자
# 그럼 각각의 번호를 1, 2, 3, 4, 5라고 붙였을때
# 내가 5번축구선수라고 가정하고 난 4번한테공을준다
# 그럼 4번은 3번 3번은2번 2번은 1번한테공을준다
# 이때 1번은 더 이상 공을 줄 곳이 없기 때문에 (필요시 로직에따라 달라질 수 있음)
# 여기서 1번은 더이상 공을 줄 곳이 없다 == 이 뜻은 재귀의 끝부분에 도달했다라고 생각할 수 있다.
# 그렇다면 1번은 "줄 사람은 없어도" 다시 "돌려줄 사람은 있다."
# 누구? 바로 2번 물론 3, 4,5번한테는 줄 수 없다는 가정하다
# 만약 3, 4, 5번한테줄 수 있다면 따로 재귀조건을 걸어 1번이 공을 더 이상 줄 곳이 없을때
# 특정한 선수한테 주게끔 만들면 된다.

# 하지만 여기서는 그게 아니기 때문에

# 2번한테 돌려줄 수 있다고 한다면
# 1은 오케이 공하나 더가져가 하면서 공을 하나 더 얹어준다
# 그럼 2번은 처음에 1번한테 공을 한개만 넘겨준 상태였다.

# 하지만 1번의 선수는 인심써서 공을한개더주어 1+1 = 2 총 공의 개수는 2가 된것이다.
# 그렇게 된다면 2번이 다시 받은 공의 개수는 총 2개가 된 것이고
# 2번은 다시 1번한테 줄 수 있지만 그렇게 주지 않고 3번한테 준다 (물론 여기도 필요에따라 로직을 조정할 수 있다.)

# 1번이 하나더 준게 빡쳐서 2번도 3번한테 하나더얹어준다 2+1 = 3총 3개를리턴해준다.
# 그럼 3번은 3개를 받게 되고 4번은 또 3번의 화의 불똥튀겨 4개를 받게된다
# 이렇게 5번은 5개를 받게 되어 공의 총 개수는 5가 된다는 것이다.

# 이걸 구현해본다면

# n이 축구선수라고 가정한다면 5번축구선수부터 시작할거다.
# 5번 축구선수는 1번 축구 선수가 아니기 때문에
# 다음 4번한테 축구공하나를 얹어서준다.


# 근데 왜그러는거지 아닌가 
def gong(n):
    if n == 1:
    	print("{%d}선수 공의 개수 : {%d}" % (n, 1))
    	return 1
    else:
        result = gong(n-1) + 1
        print("{%d}선수 공의 개수 : {%d}" % (n, result))
        return result
gong(5)