# import itertools
# import sys
# N, M = map(int, sys.stdin.readline().split())
# num = sorted(list(map(int, sys.stdin.readline().strip().split())))

# # 중복순열을 써야하는구나
# # 난 그냥 순열과 조합만 알고 있었는데 이건 중복순열 문제구나
# # 왜냐면 중복이 허용돼 왜 허용되냐면 
# # 예제에서 알 수 있듯이
# # 577은 K 의 집합에서 1, 5, 7이 있을때 	
# # 7이 두번 나온걸 확인할 수 잇고
# # 만약 중복을 허용하지 않는다면
# # 아마 가장 큰 수는 571 이다
# # 왜냐면 중복을 허용하지 않으면서 가장 큰 수기 때문이지
# # 그리고 N을 넘어가면 안되니까
# # 결국 500~675전까지 K의 집합 범위 내에서
# # 가장 크려면 결국 백의 자리가 7을 제외한 나머지 가장 큰 값인 5가 와야 하고
# # 중복을 허용하지 않으니 517 보다 571 이 더 큰 것을 알 수 있따
# # 중복순열이라는걸 캐치했으면 좋았을 것 같은 문제이다
	


# result = 0
# for i in range(N+1):
# 	check = list(str(i))
# 	cnt = 0
# 	for j in range(len(check)):
# 		if int(check[j]) in num:
# 			cnt += 1
# 	if cnt >= M:
# 		result = "".join(check)
# print(result)
# # 100000000 1
# # 1


from itertools import product

n, k = map(int, input().split())
arr = list(map(str, input().split()))
length = len(str(n))


while True:  # repeat을 통해 몇개를 뽑을지 설정한다.
    ex = []
    for i in product(arr, repeat=length):
        check = "".join(map(str, i))
        if int(check) <= n:
            ex.append(i)
    # 3자리 수라면 자리수에서 최댓값이 나온다면 
    # 그때의 최댓값을 입력하면 되고
    # 만약 최댓값이 나오지 않는다면
    # 두자리 수를 만들어서 중복순열을 조합해 만들어주고
    # 그렇게 해서 자릿수마다 가장 큰 값이 나온다면
    # 그 값이 바로 가장 큰 값이 된다.
    if len(ex) >= 1:
        print("".join(list(map(str, max(ex)))))
        break
    else:
        length -= 1


# 일단 이 문제는 처음보자 마자
# K 범위 숫자가 다 들어가면서 가장 큰 값을 찾아야 하는걸로 생각했따
# 즉 중복은 생각했는데 이게 중복순열까지 생각이 이어지지 않았으며
# 수를 나열해봤을 때 중복순열인걸 눈치를 챘어야 했는데
# check로 리스트를 만들어서 그 숫자들을 하나씩 num 값과 대조해
# 만약 값이 있으면 올리고 값이 없으면 cnt 를 내리는 방식으로 해서
# 예제 케이스는 맞았지만 다른 반례가 틀리게 나온다 999를 출력해야 되는데 4099가 나오게 된다
# 만약 489라고 한다면 0이 들어간다면 k의 범위 내에 조건을 무시하게 되므로
# 이것 또한 캐치했어야 했다
# 하지만 난 조건 검사를K 와 같거나 크다면 무조건 가장 큰 값이라고 착각ㅇ르 했다
# 그렇기에 4099값이 3개의 값이 k의 범위내에 다 들어있기 때문에
# k의 범위를 무시한 최대값이 출력되는 것이다
# 즉 k의 범위를 생각한다면
# 그 숫자가 들어있으면서 가장 큰 값을 찾으면 된다고 생각했다



# 때문에 이 문제는 일단 중복순열로 접근을 해야 하고
# 수를 나열해 봤을때 중복된 수가 나열되는걸 캐치한다음
# 수를 만들지만 중복이 가능하다는 점에서
# 이미 힌트를 주었다
# 그래서 자리수를 맞춰 중복순열 값들을 만들고
# 그 중복순열 값들이 N 값보다 작거나 같다면 따로 리스트를 만들어서 넣어주고
# 여기서 주의해야할 점이 자리수가 가장 클때 없을 수도 있다는 것이다
# 가령 10000 인데 k = 1
# 이라고 한다면 9999 가 10000보다 바로 아래의 숫자이고
# 10000 자릿수에서넌 k = 1 인데 1을 제외하고 나머지 자릿수가 0이기 때문에
# 반드시 k로 이루어진 수가 아니게 된다
# 따라서 자릿수를 하나 줄이게 되는데
# 그렇게 되었을때 가장 큰 값이 바로 1111 값이 되는 것이다
# 왜냐하면 k= 1 이고 1이 가장 많이 들어가 있는 값이 1111 이기 때문이다
# 즉 가장큰 자릿수에서 없을 수 있기 때문에
# 자릿수를 줄여가면서 검사해야 된다는 점을 생각해내야 했다
# 자릿수를 줄인다음 N-1 자릿수에서 가장 큰 값이 나올 수 있기 때문이다
# 이 문제는 중복순열과 자릿수관계 문제라고 생각한다
# 한 3일간 문제를 고민하고 시간초과, 메모리초과, 틀림을 반복해보니
# 문제의 패턴 정도를 정신차리고 분석해야 된다는 생각을 한다
# 중복순열을 조금만더 빨리 캐치해서 파이썬에서 중복순열을 구현 하는 방법을
# 알고 빠르게 풀었다면
# 자릿수 문제에서 고민을 했을것이다
# 여러 반례를 통해서 자릿수를 고려해야 된다는걸 더 빨리 생각할 수 있었지 않을까 생각이든다.



# 일단 순열이라는게 P = permutations 반복가능한 객체인 길이가 n인 거에 대해서
# k를 뽑아 나열하는 수이고
# 이떄 순서가 중요하다는 의미는 예를 들어 2개의숫자가 있다고 할 때
# 1, 2를 뽑는 순서와 2, 1을 뽑는 순서는 다르기 때문에
# 즉 뽑는 순서가 다르면 경우의 수도 다르다고 봐야 하기 때문에

# 만약 12 와 21 두개의 경우의 수를 다르게 볼때
# 이럴경우 결과가 12 와 21이 명확하게 보일경우 이것은 순열이라고 할 수 있다 왜?
# 순서가 정해져있다는건 같은 수라도 경우의 수를 다르게 본다는 의미이기 때문이다


# 조합은 C = combinations 반복가능한 객체인 길이가 n인 거에 대해서
# k개를 뽑아 조합하는 수이고
# 순열과 다르게 같은 수가 뽑힌거에 대해서 경우의 수를 생각하지 않느다
# 즉 1, 2 를 뽑았으면 2, 1을 뽑는게 같다고 본다 즉 경우의 수를 다르게 생각하지 않고
# 같은 수를 뽑는 경우의 수는 그저 한 가지 경우의 수로 생각한다는 의미이다
# 12 나 21은 조합에서는 같은 숫자가 뽑힌 것이기 때문에
# 경우의 수를 하나라고 본다

# 즉 다시 말해 뽑은 순서가 중요한 순열 1을뽑고 2를 뽑는 경우와 2를 뽑고 1를 뽑는 경우를 다르게
# 생각하는 순열과 달리 조합은 1을 뽑고 2를 뽑든 2를먼저 뽑고 1을 뽑든 순서에 상관을 쓰지 않는다는 의미가 된다


# 여기서 중복이란건 서로 다른 숫자를 사용해서 만들어야 된다는걸 의미한다
# 이때 중복순열이라는게 있는데 이때는 같은 수를 여러번 사용해도 된다
# 하지만 순열이기 때문에 나열하는데 순서가 중요하다
# 중복순열이기 때문에 n파이r = n^r 
