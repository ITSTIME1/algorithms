import sys

input = sys.stdin.readline

# 자신의 위치에서 거리가 K이하인 햄버거를 먹을 수 있다.(거리가 K까지 먹을 수 있다는 것.)

# 문제에서 구하고자하는것은 햄버거를 먹을 수 있는 사람의 최대수를 구하는것
# 그럼 다른말로 햄버거를 최대한 모두가 다 먹을 수 있는 방법으로 구해야 된다는걸 의미하는것이네


# 일단 문제를좀 해석해보자면
# 사람이 있는 위치는 P로 표현하고 햄버거의 위치는 H라고 표현한다
# 식탁의 길이는 곧 사람 + 햄버거의 수가 된다.

# 먼저 첫번째 예시를 좀 보면
# k=1일때
# 몇명의 사람이 햄버거를 먹을 수 있겠는가 하는 문제이다.

# 최대 5명이 먹을 수 있는데 12번의 사람은 10번 위치한 사람이 11번을 선택했기 때문에
# 12번은 먹을 수 있는 햄버거가 왼쪽에만 있고 오른쪽에는 더이상 없기 때문에
# 먹을 수 없다
# 그럼 10번 위치해 있는 사람은 결국
# 6번 위치해 있는 사람이 7번 햄버거를 먹었기 때문에 연속으로 되어있는 햄버거의 위치상
# 9번은 8번을 먹을 수 밖에 없다
# 따라서 10번은 9번에 의해서 11번을 선택할 수 밖에 없어진 것이다.


# 이 예제에서의 가장 큰 원인은 4번이라고 볼 수 있다.
# 그 이유는 4번이 위치한 곳에서 3번에 위치한 햄버거는 먹지 않았기 때문이다.
# 만약 4번이 3번 햄버거를 먹는다면
# 6번은 5번햄버거를 먹으면되고
# 9번 사람은 7번을 
# 10번은 8번을 먹게 된다면
# 12번이 11번 햄버거를 먹을 수 있게 된다.

# 그렇게 되면 모두가 햄버거를 먹을 수 있게된다.

# 그럼 햄버거를 먹거위해 최선의 선택은 무엇이될까

# 9번 사람이 7번햄버거를 먹게 되는 것 처럼
# "자기의 가장 왼쪽에서 먹을 수 있는 햄버거를 먹어준다면"
# 다음 사람이 먹을 햄버거를 침범하지 않게 된다.


# 그럼 예제를좀보자
# k를 고려해서 보아야한다.
# 결국 거리가 K라고 했기 때문에 왼쪽 오른쪽 K를 다 생각해주어야한다
# 그중에서 K거리 이내에서 먹을 수 있는 햄버거를 왼쪽부터 먹어주고
# 만약 먹을 것이 없다면 오른쪽에 K거리 이내에 있다면 먹어준다.
# 맞을까

# H (H P) (H P) (P H) (H P) (P H) P P (P H) (P H) (P H) P = 8 명이 먹을 수 있다.



# 20 2
# H H H H H P P P P P H P H P H P H H H P

# 1. 먹었다는걸 표시하기 위해서 사람을 먼저 찾고 그 사람에 위치에서 k만큼 왼쪽부터탐색 만약 있다면
# H를 다른 문자열로 표기하고 사람도 다른 문자열로 표기
# 2. 만약 왼쪽을 탐색했을때 먹을 수 있는 햄버거가 존재하지 않는다면 오른쪽을 탐색
# 오른쪽도 마찬가지로 먹을 수 있는 햄버거가 있다면 그 햄버거의 위치와 사람의 위치를 다른 문자열로 표현
# 3. 먹는 순간에 p먹은 사람의 개수를 카운트해주어야 되기 때문에 cnt변수를 증가
# 4. 그러면 되겠는데
# 그럼 N에서 사람 수만큼 탐색하게 될것이고 + 그 사람에서 왼쪽에 있다면 k만큼 왼쪽에 없다면 2K만큼 탐색하게 될거고
# 결국 N * K만큼 탐색하게 된다.

# 오른쪽에서 먹을때도
# 가장 멀리있는걸 먹어야겠네

# 왼쪽은 먹을 수 잇으면 먹고
# 오른쪽을 먹기위해서는 가장 가깝지 않다면 먹지 않는다
# cnt = 0

# for i in range(n):
# 	if l[i] == "P":
# 		for j in range(max(i-k, 0), min(i+k+1, n)):
# 			if l[j] == "H":
# 				cnt += 1
# 				l[i], l[j] = "X", "X"
# 				break
# print(cnt)

# 그니까 처음에 사람이 오는거랑 마지막에 사람이 오는거에서 꼬였구나
# 
# 처음과 마지막에 오는 사람은 우선 처음에 오는 사람은 0보다 작아지는걸 탐색할 수 없으니
# 그 자리에서 오른쪽밖에 탐색하지 못한다.
# 그럼 오른쪽에서 탐색할때 가장 먼저 오는걸 먹어준다


# 아 구간을 생각해야되었던거구나
# 즉 구간이 첫번째랑 마지막이 아니더라도
# 구간이 문제가 될 수 있음
# K가 10까지 주어지기 떄문에
# 만약 10보다 작거나 같은 구간이 주어진다고 한다면
# 예를들어 9가 주어졌다고 했을떄
# 왼쪽탐색을 진행할때 9-10 만큼 진행하게 되면 벌써 0보다 작아지는 경우가 생긴다
# 그렇다는건 이 경우를 고려해야 된다는걸 말하는데
# 이 경우를 고려하기 위해서는 
# 넘어가지 않도록 0부터 시작점을 잡아줘야한다는의미가된다.
# 따라서 만약 음수의 구간이 생긴다면
# 범위를 바꿔주어야한다.
# cnt = 0
# for i in range(n):
# 	if l[i] == "P":
# 		# 구간을좀 신경써준다면
# 		# 음수가 나오거나 최대를 넘어가는 경우가 생길 수 있다.
# 		# 그런경우에는 최소 최대를 0과 n으로 잡아주어야한다.
# 		# 그렇다는건 결국 작아지는 구간이 항상 0보다 크거나 같아야되기떄문에
# 		# 작아진다면 0을선택하게하고
# 		# 만약 최대보다 커지게 된다면
# 		# 최대로 한정하게한다.
# 		# 최대보다 커진다는건 곧 최대가 더 작아진다는걸 의미하기 때문에
# 		min, max = 
	
# print(cnt)


import sys
input = sys.stdin.readline

n, k = map(int, input().strip().split())
l = list(map(str, input().strip()))


idx, cnt = 0, 0
while idx < n:
	min, max = idx - k, idx + k + 1
	if l[idx] == "P":

		if idx - k < 0:
			min = 0

		if idx + k + 1 >= n:
			max = n

		for i in range(min, max):
			if l[i] == "H":
				cnt +=1 
				l[idx], l[i] = "X", "X"
				break
	idx += 1
print(cnt)
# for i in range(n):
# 	# 중간
# 	if l[i] == "P" and i != n-1:
# 		flag = True
# 		for j in range(i-k, i):
# 			if l[j] == "H":
# 				l[j], l[i] = "X", "X"
# 				cnt += 1
# 				break
# 			else:
# 				flag = False

# 		if flag == False:
# 			s = l[i+1:i+k+1]
# 			if s[-1] == "H" and "P" in s and len(s) != 1:
# 				continue
	
# 			else:
# 				for c in range(i, i+k+1):
# 					if l[c] == "H":
# 						l[c], l[i] = "X", "X"
# 						cnt += 1
# 						break

# 	elif l[i] == "P" and i == 0:
# 		s = l[i+1:i+k+1]
# 		if s[-1] == "H" and "P" in s:
# 			break
# 		else:
# 			for c in range(i+1, i+k+1):
# 				if l[c] == "H":
# 					l[c], l[i] = "X", "X"
# 					cnt += 1
# 					break

# 	elif l[i] == "P" and i == n-1:
# 		for j in range(i-k, i):
# 			if l[j] == "H":
# 				l[j], l[i] = "X", "X"
# 				cnt += 1
# 				break

# print(cnt)