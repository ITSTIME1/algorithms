import sys
import heapq
from collections import deque
from itertools import permutations, combinations, product, combinations_with_replacement
input = sys.stdin.readline


# 일단 문제부터 해석해보자면
# N개의 로프를 이용해서 최대중량의 물체를 들어올린다고 한다.


# 그랬을때 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다고 한다.


# 자 그랬을때 중량을 로프의 개수만큼의 힘의 분산이 이루어지면
# 물체의 최대 중량은 어떻게 될까 라는 문제이다

# 우선 예시를 살펴보면

# 로프의 개수가 2개 주어지고
# 1번 로프는 최대 10까지 버틸 수 있고
# 2번 로프는 최대 15까지 버틸 수 있다.

# 자 그랬을때
# 경우의 수를 좀 생각해본다면
# 1번 로프만을 사용했을때는 10 만큼이 최대
# 2번 로프만을 사용한다면 15만큼이 최대가 된다.

# 하지만 1번 로프 2번 로프를 사용하게 되면
# 1번로프에도 최대중량 10이 걸리게 되고
# 2번로프에도 최대중량 10이 걸릴 수 있어 총 20만큼의 중량을 들어 올릴 수 있다.

# 그 이유는 만약 2번 로프가 11이나 12까지 들어버리게 되면
# 결국 1번 로프는 버티지 못하고 끊기게 된다.
# 따라서 최대중량이란건 가장 적게 들어올리는 로프가 들어올릴 수 있는 한계치가 된다.

# 다시말해 1번 로프 2번 로프중 12를 들어올리게 되면
# 1번 로프는 끊어지기 때문에 결국 12만큼 들어올리게 되어 최대중량을 들어올리는게 아니다.

# 따라서 1번 로프가 들 수 있는 최대중량을 지키면서 2번로프또한 그 중량에 맞춘다면
# 10 + 10으로 최대중량을 들 수 있게 된다.

# 그럼 결국 10 + 10 = 10 * 2로 쓸 수 있으며
# 수식화 한다면 가장 적은 물체를 들어올릴 수 있는 로프의 무게 * 로프의 개수가 된다.
# 때문에 min(arr) * len(arr) 이 되어 최대로 들수 있는 중량은 20이된다.

# 아 로프를 선택적으로 골라서 들었을때의 무게들이 다를 수 있구나
# 10인 로프 하나를 사용해서 들면 10
# 10, 8 들면 8 * 2 = 16
# 10, 8, 7 7 * 3 = 21
# 10 8, 7, 5 * 4 = 20
# 이런식으로 로프의 최대중량의 따라 들 수 있는 중량이 달라진다.



n = int(input())

arr = [int(input()) for i in range(n)]

arr.sort(reverse=True)
# 큰 로프순서대로 정렬해둔다면
# 가장 작은 로프를 기준으로 최대중량을 정할 수 있다.
ar = [arr[i] * (i+1) for i in range(len(arr))]
print(max(ar))
