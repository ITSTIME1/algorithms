# 1. 첫번째부터 시작해서 루프를 돌건데 해당 값보다 작거나 같은 값을 모조리 리스트에다가 넣는다.

# 2. 만약 자기 보다 큰값이 하나라도 들어가 있다면 루프를 종료하고 해당 인덱스로 다시 루프를 재조정 즉 루프를 도는 기준을 다시 설정
# 3. 만약 그렇지 않다면 "자기보다 작거나 같은값을 가진 것"들을 모조리 리스트에 넣은다음
# 4. 자기보다 큰 값을 만났다면 해당 큰 값의 인덱스를 저장 후 종료 해당 리스트에서 가장 작은 값을 기준으로 [1:len()-2]까지 차이를구해서 합산
# 5. 루프 기준 인덱스 마지막 인덱스로 설정
# 6. -가 있을경우 고이지 않는것


import sys
input = sys.stdin.readline


h, w = map(int, input().split())

b = list(map(int, input().split()))


# 한칸한칸씩 보자

total = 0
for i in range(w):
	# 담는다는건 두 값중 작은 값을 기준으로 채울 수 있다는것 만약 3, 3결국 3을 기준으로 채울 수 있는거지
	# 0자리에는 채워질 수 가 없자나
	# 가장 왼족부터 채워지기 떄문에 블럭의 높이가
	# 설령 0 이라고 하더라도 그 옆에는 없으니까
	# 그럼 마지막도 마찬가지로
	# 블럭 내부의 빈공간은 없다는거지
	# 빈공간이 있다면 첫번째와 마지막도 채울 수 이쓴ㄴ데
	# 0, w-1까지 블럭으 ㅣ높이로 꽉채우고 있으니까
	if i == 0 or i == w-1:
		continue 
	l = max(b[:i])
	r = max(b[i+1:])


	stand = min(l, r)
	if stand-b[i] < 0: continue
	total += stand - b[i]
print(total)